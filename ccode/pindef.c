/* pindef.c generated by valac 0.20.1, the Vala compiler
 * generated from pindef.vala, do not modify */

/* 
 * SmartSim - Digital Logic Circuit Designer and Simulator
 *   
 *   Expansion Version
 *   
 *   Filename: pindef.vala
 *   
 *   Copyright Ashley Newson 2012
 */

#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <libxml/tree.h>
#include <stdio.h>
#include <libxml/xmlwriter.h>
#include <cairo.h>
#include <gobject/gvaluecollector.h>


#define TYPE_PIN_DEF (pin_def_get_type ())
#define PIN_DEF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PIN_DEF, PinDef))
#define PIN_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PIN_DEF, PinDefClass))
#define IS_PIN_DEF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PIN_DEF))
#define IS_PIN_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PIN_DEF))
#define PIN_DEF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PIN_DEF, PinDefClass))

typedef struct _PinDef PinDef;
typedef struct _PinDefClass PinDefClass;
typedef struct _PinDefPrivate PinDefPrivate;

#define TYPE_DIRECTION (direction_get_type ())

#define TYPE_FLOW (flow_get_type ())

#define PIN_DEF_TYPE_LABEL_TYPE (pin_def_label_type_get_type ())
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _ParamSpecPinDef ParamSpecPinDef;

typedef enum  {
	DIRECTION_NONE,
	DIRECTION_RIGHT,
	DIRECTION_DOWN,
	DIRECTION_LEFT,
	DIRECTION_UP,
	DIRECTION_HORIZONTAL,
	DIRECTION_VERTICAL,
	DIRECTION_DIAGONAL
} Direction;

typedef enum  {
	FLOW_NONE,
	FLOW_IN,
	FLOW_OUT,
	FLOW_BIDIRECTIONAL
} Flow;

typedef enum  {
	PIN_DEF_LABEL_TYPE_NONE,
	PIN_DEF_LABEL_TYPE_TEXT,
	PIN_DEF_LABEL_TYPE_TEXTBAR,
	PIN_DEF_LABEL_TYPE_CLOCK
} PinDefLabelType;

struct _PinDef {
	GTypeInstance parent_instance;
	volatile int ref_count;
	PinDefPrivate * priv;
	gint x;
	gint y;
	gint xLabel;
	gint yLabel;
	gint xConnect;
	gint yConnect;
	Direction direction;
	gint length;
	gboolean array;
	Flow flow;
	gint defaultArraySize;
	gint idealSpace;
	gfloat minSpace;
	gchar* label;
	gboolean required;
	gboolean userArrayResize;
	gboolean showDefault;
	PinDefLabelType labelType;
};

struct _PinDefClass {
	GTypeClass parent_class;
	void (*finalize) (PinDef *self);
};

struct _ParamSpecPinDef {
	GParamSpec parent_instance;
};


static gpointer pin_def_parent_class = NULL;

gpointer pin_def_ref (gpointer instance);
void pin_def_unref (gpointer instance);
GParamSpec* param_spec_pin_def (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_pin_def (GValue* value, gpointer v_object);
void value_take_pin_def (GValue* value, gpointer v_object);
gpointer value_get_pin_def (const GValue* value);
GType pin_def_get_type (void) G_GNUC_CONST;
GType direction_get_type (void) G_GNUC_CONST;
GType flow_get_type (void) G_GNUC_CONST;
GType pin_def_label_type_get_type (void) G_GNUC_CONST;
enum  {
	PIN_DEF_DUMMY_PROPERTY
};
PinDef* pin_def_new (gint x, gint y, Direction direction, Flow flow, gint length, gboolean array, gint defaultArraySize, gint idealSpace, gfloat minSpace, const gchar* label, PinDefLabelType labelType, gboolean required, gboolean userArrayResize, gboolean showDefault);
PinDef* pin_def_construct (GType object_type, gint x, gint y, Direction direction, Flow flow, gint length, gboolean array, gint defaultArraySize, gint idealSpace, gfloat minSpace, const gchar* label, PinDefLabelType labelType, gboolean required, gboolean userArrayResize, gboolean showDefault);
void pin_def_set_position (PinDef* self, gint x, gint y, gint length, Direction direction);
PinDef* pin_def_new_load (xmlNode* xmlnode);
PinDef* pin_def_construct_load (GType object_type, xmlNode* xmlnode);
void pin_def_save (PinDef* self, xmlTextWriter* xmlWriter, gint id);
void pin_def_render (PinDef* self, cairo_t* context, gboolean invert);
static void pin_def_finalize (PinDef* obj);


/**
 * Describes the appearance of the label
 */
GType pin_def_label_type_get_type (void) {
	static volatile gsize pin_def_label_type_type_id__volatile = 0;
	if (g_once_init_enter (&pin_def_label_type_type_id__volatile)) {
		static const GEnumValue values[] = {{PIN_DEF_LABEL_TYPE_NONE, "PIN_DEF_LABEL_TYPE_NONE", "none"}, {PIN_DEF_LABEL_TYPE_TEXT, "PIN_DEF_LABEL_TYPE_TEXT", "text"}, {PIN_DEF_LABEL_TYPE_TEXTBAR, "PIN_DEF_LABEL_TYPE_TEXTBAR", "textbar"}, {PIN_DEF_LABEL_TYPE_CLOCK, "PIN_DEF_LABEL_TYPE_CLOCK", "clock"}, {0, NULL, NULL}};
		GType pin_def_label_type_type_id;
		pin_def_label_type_type_id = g_enum_register_static ("PinDefLabelType", values);
		g_once_init_leave (&pin_def_label_type_type_id__volatile, pin_def_label_type_type_id);
	}
	return pin_def_label_type_type_id__volatile;
}


/**
 * Creates a new PinDef which the given properties.
 */
PinDef* pin_def_construct (GType object_type, gint x, gint y, Direction direction, Flow flow, gint length, gboolean array, gint defaultArraySize, gint idealSpace, gfloat minSpace, const gchar* label, PinDefLabelType labelType, gboolean required, gboolean userArrayResize, gboolean showDefault) {
	PinDef* self = NULL;
	Flow _tmp0_;
	gboolean _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	gfloat _tmp4_;
	const gchar* _tmp5_;
	gchar* _tmp6_;
	PinDefLabelType _tmp7_;
	gboolean _tmp8_;
	gboolean _tmp9_;
	gboolean _tmp10_;
	gint _tmp11_;
	gint _tmp12_;
	gint _tmp13_;
	Direction _tmp14_;
	g_return_val_if_fail (label != NULL, NULL);
	self = (PinDef*) g_type_create_instance (object_type);
	_tmp0_ = flow;
	self->flow = _tmp0_;
	_tmp1_ = array;
	self->array = _tmp1_;
	_tmp2_ = defaultArraySize;
	self->defaultArraySize = _tmp2_;
	_tmp3_ = idealSpace;
	self->idealSpace = _tmp3_;
	_tmp4_ = minSpace;
	self->minSpace = _tmp4_;
	_tmp5_ = label;
	_tmp6_ = g_strdup (_tmp5_);
	_g_free0 (self->label);
	self->label = _tmp6_;
	_tmp7_ = labelType;
	self->labelType = _tmp7_;
	_tmp8_ = required;
	self->required = _tmp8_;
	_tmp9_ = userArrayResize;
	self->userArrayResize = _tmp9_;
	_tmp10_ = showDefault;
	self->showDefault = _tmp10_;
	_tmp11_ = x;
	_tmp12_ = y;
	_tmp13_ = length;
	_tmp14_ = direction;
	pin_def_set_position (self, _tmp11_, _tmp12_, _tmp13_, _tmp14_);
	return self;
}


PinDef* pin_def_new (gint x, gint y, Direction direction, Flow flow, gint length, gboolean array, gint defaultArraySize, gint idealSpace, gfloat minSpace, const gchar* label, PinDefLabelType labelType, gboolean required, gboolean userArrayResize, gboolean showDefault) {
	return pin_def_construct (TYPE_PIN_DEF, x, y, direction, flow, length, array, defaultArraySize, idealSpace, minSpace, label, labelType, required, userArrayResize, showDefault);
}


/**
 * Loads a PinDef from a file using libxml.
 */
static gboolean bool_parse (const gchar* str) {
	gboolean result = FALSE;
	const gchar* _tmp0_;
	g_return_val_if_fail (str != NULL, FALSE);
	_tmp0_ = str;
	if (g_strcmp0 (_tmp0_, "true") == 0) {
		result = TRUE;
		return result;
	} else {
		result = FALSE;
		return result;
	}
}


static gdouble double_parse (const gchar* str) {
	gdouble result = 0.0;
	const gchar* _tmp0_;
	gdouble _tmp1_ = 0.0;
	g_return_val_if_fail (str != NULL, 0.0);
	_tmp0_ = str;
	_tmp1_ = g_ascii_strtod (_tmp0_, NULL);
	result = _tmp1_;
	return result;
}


PinDef* pin_def_construct_load (GType object_type, xmlNode* xmlnode) {
	PinDef* self = NULL;
	gchar* _tmp0_;
	gint x;
	gint y;
	Direction direction;
	gint length;
	Flow _tmp80_;
	gint _tmp82_;
	gint _tmp83_;
	gint _tmp84_;
	Direction _tmp85_;
	self = (PinDef*) g_type_create_instance (object_type);
	self->flow = FLOW_NONE;
	self->array = FALSE;
	self->defaultArraySize = 1;
	self->idealSpace = 0;
	self->minSpace = (gfloat) 0;
	_tmp0_ = g_strdup ("");
	_g_free0 (self->label);
	self->label = _tmp0_;
	self->labelType = PIN_DEF_LABEL_TYPE_NONE;
	self->required = TRUE;
	self->userArrayResize = TRUE;
	self->showDefault = TRUE;
	x = 0;
	y = 0;
	direction = DIRECTION_NONE;
	length = 1;
	{
		xmlNode* _tmp1_;
		xmlAttr* _tmp2_;
		xmlAttr* xmlattr;
		_tmp1_ = xmlnode;
		_tmp2_ = _tmp1_->properties;
		xmlattr = _tmp2_;
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				gboolean _tmp4_;
				xmlAttr* _tmp7_;
				xmlAttr* _tmp8_;
				const gchar* _tmp9_;
				const gchar* _tmp10_;
				GQuark _tmp12_ = 0U;
				static GQuark _tmp11_label0 = 0;
				static GQuark _tmp11_label1 = 0;
				static GQuark _tmp11_label2 = 0;
				static GQuark _tmp11_label3 = 0;
				static GQuark _tmp11_label4 = 0;
				static GQuark _tmp11_label5 = 0;
				static GQuark _tmp11_label6 = 0;
				static GQuark _tmp11_label7 = 0;
				static GQuark _tmp11_label8 = 0;
				static GQuark _tmp11_label9 = 0;
				static GQuark _tmp11_label10 = 0;
				static GQuark _tmp11_label11 = 0;
				static GQuark _tmp11_label12 = 0;
				static GQuark _tmp11_label13 = 0;
				static GQuark _tmp11_label14 = 0;
				_tmp4_ = _tmp3_;
				if (!_tmp4_) {
					xmlAttr* _tmp5_;
					xmlAttr* _tmp6_;
					_tmp5_ = xmlattr;
					_tmp6_ = _tmp5_->next;
					xmlattr = _tmp6_;
				}
				_tmp3_ = FALSE;
				_tmp7_ = xmlattr;
				if (!(_tmp7_ != NULL)) {
					break;
				}
				_tmp8_ = xmlattr;
				_tmp9_ = _tmp8_->name;
				_tmp10_ = _tmp9_;
				_tmp12_ = (NULL == _tmp10_) ? 0 : g_quark_from_string (_tmp10_);
				if (_tmp12_ == ((0 != _tmp11_label0) ? _tmp11_label0 : (_tmp11_label0 = g_quark_from_static_string ("x")))) {
					switch (0) {
						default:
						{
							xmlAttr* _tmp13_;
							xmlNode* _tmp14_;
							const gchar* _tmp15_;
							gint _tmp16_ = 0;
							_tmp13_ = xmlattr;
							_tmp14_ = _tmp13_->children;
							_tmp15_ = _tmp14_->content;
							_tmp16_ = atoi (_tmp15_);
							x = _tmp16_;
							break;
						}
					}
				} else if (_tmp12_ == ((0 != _tmp11_label1) ? _tmp11_label1 : (_tmp11_label1 = g_quark_from_static_string ("y")))) {
					switch (0) {
						default:
						{
							xmlAttr* _tmp17_;
							xmlNode* _tmp18_;
							const gchar* _tmp19_;
							gint _tmp20_ = 0;
							_tmp17_ = xmlattr;
							_tmp18_ = _tmp17_->children;
							_tmp19_ = _tmp18_->content;
							_tmp20_ = atoi (_tmp19_);
							y = _tmp20_;
							break;
						}
					}
				} else if (_tmp12_ == ((0 != _tmp11_label2) ? _tmp11_label2 : (_tmp11_label2 = g_quark_from_static_string ("direction")))) {
					switch (0) {
						default:
						{
							xmlAttr* _tmp21_;
							xmlNode* _tmp22_;
							const gchar* _tmp23_;
							const gchar* _tmp24_;
							GQuark _tmp26_ = 0U;
							static GQuark _tmp25_label0 = 0;
							static GQuark _tmp25_label1 = 0;
							static GQuark _tmp25_label2 = 0;
							static GQuark _tmp25_label3 = 0;
							_tmp21_ = xmlattr;
							_tmp22_ = _tmp21_->children;
							_tmp23_ = _tmp22_->content;
							_tmp24_ = _tmp23_;
							_tmp26_ = (NULL == _tmp24_) ? 0 : g_quark_from_string (_tmp24_);
							if (_tmp26_ == ((0 != _tmp25_label0) ? _tmp25_label0 : (_tmp25_label0 = g_quark_from_static_string ("left")))) {
								switch (0) {
									default:
									{
										direction = DIRECTION_LEFT;
										break;
									}
								}
							} else if (_tmp26_ == ((0 != _tmp25_label1) ? _tmp25_label1 : (_tmp25_label1 = g_quark_from_static_string ("down")))) {
								switch (0) {
									default:
									{
										direction = DIRECTION_DOWN;
										break;
									}
								}
							} else if (_tmp26_ == ((0 != _tmp25_label2) ? _tmp25_label2 : (_tmp25_label2 = g_quark_from_static_string ("right")))) {
								switch (0) {
									default:
									{
										direction = DIRECTION_RIGHT;
										break;
									}
								}
							} else if (_tmp26_ == ((0 != _tmp25_label3) ? _tmp25_label3 : (_tmp25_label3 = g_quark_from_static_string ("up")))) {
								switch (0) {
									default:
									{
										direction = DIRECTION_UP;
										break;
									}
								}
							} else {
								switch (0) {
									default:
									{
										direction = DIRECTION_NONE;
										break;
									}
								}
							}
							break;
						}
					}
				} else if (_tmp12_ == ((0 != _tmp11_label3) ? _tmp11_label3 : (_tmp11_label3 = g_quark_from_static_string ("length")))) {
					switch (0) {
						default:
						{
							xmlAttr* _tmp27_;
							xmlNode* _tmp28_;
							const gchar* _tmp29_;
							gint _tmp30_ = 0;
							_tmp27_ = xmlattr;
							_tmp28_ = _tmp27_->children;
							_tmp29_ = _tmp28_->content;
							_tmp30_ = atoi (_tmp29_);
							length = _tmp30_;
							break;
						}
					}
				} else if (_tmp12_ == ((0 != _tmp11_label4) ? _tmp11_label4 : (_tmp11_label4 = g_quark_from_static_string ("flow")))) {
					switch (0) {
						default:
						{
							xmlAttr* _tmp31_;
							xmlNode* _tmp32_;
							const gchar* _tmp33_;
							const gchar* _tmp34_;
							GQuark _tmp36_ = 0U;
							static GQuark _tmp35_label0 = 0;
							static GQuark _tmp35_label1 = 0;
							static GQuark _tmp35_label2 = 0;
							_tmp31_ = xmlattr;
							_tmp32_ = _tmp31_->children;
							_tmp33_ = _tmp32_->content;
							_tmp34_ = _tmp33_;
							_tmp36_ = (NULL == _tmp34_) ? 0 : g_quark_from_string (_tmp34_);
							if (_tmp36_ == ((0 != _tmp35_label0) ? _tmp35_label0 : (_tmp35_label0 = g_quark_from_static_string ("in")))) {
								switch (0) {
									default:
									{
										self->flow = FLOW_IN;
										break;
									}
								}
							} else if (_tmp36_ == ((0 != _tmp35_label1) ? _tmp35_label1 : (_tmp35_label1 = g_quark_from_static_string ("out")))) {
								switch (0) {
									default:
									{
										self->flow = FLOW_OUT;
										break;
									}
								}
							} else if (_tmp36_ == ((0 != _tmp35_label2) ? _tmp35_label2 : (_tmp35_label2 = g_quark_from_static_string ("bi")))) {
								switch (0) {
									default:
									{
										self->flow = FLOW_BIDIRECTIONAL;
										break;
									}
								}
							} else {
								switch (0) {
									default:
									{
										FILE* _tmp37_;
										_tmp37_ = stdout;
										fprintf (_tmp37_, "Error: Invalid flow\n");
										break;
									}
								}
							}
							break;
						}
					}
				} else if (_tmp12_ == ((0 != _tmp11_label5) ? _tmp11_label5 : (_tmp11_label5 = g_quark_from_static_string ("array")))) {
					switch (0) {
						default:
						{
							xmlAttr* _tmp38_;
							xmlNode* _tmp39_;
							const gchar* _tmp40_;
							gboolean _tmp41_ = FALSE;
							_tmp38_ = xmlattr;
							_tmp39_ = _tmp38_->children;
							_tmp40_ = _tmp39_->content;
							_tmp41_ = bool_parse (_tmp40_);
							self->array = _tmp41_;
							break;
						}
					}
				} else if (_tmp12_ == ((0 != _tmp11_label6) ? _tmp11_label6 : (_tmp11_label6 = g_quark_from_static_string ("arraydefault")))) {
					switch (0) {
						default:
						{
							xmlAttr* _tmp42_;
							xmlNode* _tmp43_;
							const gchar* _tmp44_;
							gint _tmp45_ = 0;
							_tmp42_ = xmlattr;
							_tmp43_ = _tmp42_->children;
							_tmp44_ = _tmp43_->content;
							_tmp45_ = atoi (_tmp44_);
							self->defaultArraySize = _tmp45_;
							break;
						}
					}
				} else if (_tmp12_ == ((0 != _tmp11_label7) ? _tmp11_label7 : (_tmp11_label7 = g_quark_from_static_string ("idealspace")))) {
					switch (0) {
						default:
						{
							xmlAttr* _tmp46_;
							xmlNode* _tmp47_;
							const gchar* _tmp48_;
							gint _tmp49_ = 0;
							_tmp46_ = xmlattr;
							_tmp47_ = _tmp46_->children;
							_tmp48_ = _tmp47_->content;
							_tmp49_ = atoi (_tmp48_);
							self->idealSpace = _tmp49_;
							break;
						}
					}
				} else if (_tmp12_ == ((0 != _tmp11_label8) ? _tmp11_label8 : (_tmp11_label8 = g_quark_from_static_string ("minspace")))) {
					switch (0) {
						default:
						{
							xmlAttr* _tmp50_;
							xmlNode* _tmp51_;
							const gchar* _tmp52_;
							gdouble _tmp53_ = 0.0;
							_tmp50_ = xmlattr;
							_tmp51_ = _tmp50_->children;
							_tmp52_ = _tmp51_->content;
							_tmp53_ = double_parse (_tmp52_);
							self->minSpace = (gfloat) _tmp53_;
							break;
						}
					}
				} else if (_tmp12_ == ((0 != _tmp11_label9) ? _tmp11_label9 : (_tmp11_label9 = g_quark_from_static_string ("label")))) {
					switch (0) {
						default:
						{
							xmlAttr* _tmp54_;
							xmlNode* _tmp55_;
							const gchar* _tmp56_;
							gchar* _tmp57_;
							_tmp54_ = xmlattr;
							_tmp55_ = _tmp54_->children;
							_tmp56_ = _tmp55_->content;
							_tmp57_ = g_strdup (_tmp56_);
							_g_free0 (self->label);
							self->label = _tmp57_;
							self->labelType = PIN_DEF_LABEL_TYPE_TEXT;
							break;
						}
					}
				} else if (_tmp12_ == ((0 != _tmp11_label10) ? _tmp11_label10 : (_tmp11_label10 = g_quark_from_static_string ("barlabel")))) {
					switch (0) {
						default:
						{
							xmlAttr* _tmp58_;
							xmlNode* _tmp59_;
							const gchar* _tmp60_;
							gchar* _tmp61_;
							_tmp58_ = xmlattr;
							_tmp59_ = _tmp58_->children;
							_tmp60_ = _tmp59_->content;
							_tmp61_ = g_strdup (_tmp60_);
							_g_free0 (self->label);
							self->label = _tmp61_;
							self->labelType = PIN_DEF_LABEL_TYPE_TEXTBAR;
							break;
						}
					}
				} else if (_tmp12_ == ((0 != _tmp11_label11) ? _tmp11_label11 : (_tmp11_label11 = g_quark_from_static_string ("symlabel")))) {
					switch (0) {
						default:
						{
							xmlAttr* _tmp62_;
							xmlNode* _tmp63_;
							const gchar* _tmp64_;
							const gchar* _tmp65_;
							GQuark _tmp67_ = 0U;
							static GQuark _tmp66_label0 = 0;
							_tmp62_ = xmlattr;
							_tmp63_ = _tmp62_->children;
							_tmp64_ = _tmp63_->content;
							_tmp65_ = _tmp64_;
							_tmp67_ = (NULL == _tmp65_) ? 0 : g_quark_from_string (_tmp65_);
							if (_tmp67_ == ((0 != _tmp66_label0) ? _tmp66_label0 : (_tmp66_label0 = g_quark_from_static_string ("clock")))) {
								switch (0) {
									default:
									{
										self->labelType = PIN_DEF_LABEL_TYPE_CLOCK;
										break;
									}
								}
							} else {
								switch (0) {
									default:
									{
										self->labelType = PIN_DEF_LABEL_TYPE_NONE;
										break;
									}
								}
							}
							break;
						}
					}
				} else if (_tmp12_ == ((0 != _tmp11_label12) ? _tmp11_label12 : (_tmp11_label12 = g_quark_from_static_string ("required")))) {
					switch (0) {
						default:
						{
							xmlAttr* _tmp68_;
							xmlNode* _tmp69_;
							const gchar* _tmp70_;
							gboolean _tmp71_ = FALSE;
							_tmp68_ = xmlattr;
							_tmp69_ = _tmp68_->children;
							_tmp70_ = _tmp69_->content;
							_tmp71_ = bool_parse (_tmp70_);
							self->required = _tmp71_;
							break;
						}
					}
				} else if (_tmp12_ == ((0 != _tmp11_label13) ? _tmp11_label13 : (_tmp11_label13 = g_quark_from_static_string ("userresize")))) {
					switch (0) {
						default:
						{
							xmlAttr* _tmp72_;
							xmlNode* _tmp73_;
							const gchar* _tmp74_;
							gboolean _tmp75_ = FALSE;
							_tmp72_ = xmlattr;
							_tmp73_ = _tmp72_->children;
							_tmp74_ = _tmp73_->content;
							_tmp75_ = bool_parse (_tmp74_);
							self->userArrayResize = _tmp75_;
							break;
						}
					}
				} else if (_tmp12_ == ((0 != _tmp11_label14) ? _tmp11_label14 : (_tmp11_label14 = g_quark_from_static_string ("show")))) {
					switch (0) {
						default:
						{
							xmlAttr* _tmp76_;
							xmlNode* _tmp77_;
							const gchar* _tmp78_;
							gboolean _tmp79_ = FALSE;
							_tmp76_ = xmlattr;
							_tmp77_ = _tmp76_->children;
							_tmp78_ = _tmp77_->content;
							_tmp79_ = bool_parse (_tmp78_);
							self->showDefault = _tmp79_;
							break;
						}
					}
				}
			}
		}
	}
	_tmp80_ = self->flow;
	if (_tmp80_ == FLOW_NONE) {
		FILE* _tmp81_;
		_tmp81_ = stdout;
		fprintf (_tmp81_, "Warning: No flow\n");
	}
	_tmp82_ = x;
	_tmp83_ = y;
	_tmp84_ = length;
	_tmp85_ = direction;
	pin_def_set_position (self, _tmp82_, _tmp83_, _tmp84_, _tmp85_);
	return self;
}


PinDef* pin_def_new_load (xmlNode* xmlnode) {
	return pin_def_construct_load (TYPE_PIN_DEF, xmlnode);
}


/**
 * Changes the position the pin extends from, its length, and
 * direction, updating necessary values.
 */
void pin_def_set_position (PinDef* self, gint x, gint y, gint length, Direction direction) {
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	Direction _tmp3_;
	Direction _tmp4_;
	g_return_if_fail (self != NULL);
	_tmp0_ = x;
	self->x = _tmp0_;
	_tmp1_ = y;
	self->y = _tmp1_;
	_tmp2_ = length;
	self->length = _tmp2_;
	_tmp3_ = direction;
	self->direction = _tmp3_;
	_tmp4_ = direction;
	switch (_tmp4_) {
		case DIRECTION_NONE:
		{
			gint _tmp5_;
			gint _tmp6_;
			gint _tmp7_;
			gint _tmp8_;
			_tmp5_ = x;
			self->xConnect = _tmp5_;
			_tmp6_ = y;
			self->yConnect = _tmp6_;
			_tmp7_ = x;
			self->xLabel = _tmp7_;
			_tmp8_ = y;
			self->yLabel = _tmp8_;
			break;
		}
		case DIRECTION_RIGHT:
		{
			gint _tmp9_;
			gint _tmp10_;
			gint _tmp11_;
			gint _tmp12_;
			gint _tmp13_;
			_tmp9_ = x;
			_tmp10_ = length;
			self->xConnect = _tmp9_ + _tmp10_;
			_tmp11_ = y;
			self->yConnect = _tmp11_;
			_tmp12_ = x;
			self->xLabel = _tmp12_ - 10;
			_tmp13_ = y;
			self->yLabel = _tmp13_;
			break;
		}
		case DIRECTION_DOWN:
		{
			gint _tmp14_;
			gint _tmp15_;
			gint _tmp16_;
			gint _tmp17_;
			gint _tmp18_;
			_tmp14_ = x;
			self->xConnect = _tmp14_;
			_tmp15_ = y;
			_tmp16_ = length;
			self->yConnect = _tmp15_ + _tmp16_;
			_tmp17_ = x;
			self->xLabel = _tmp17_;
			_tmp18_ = y;
			self->yLabel = _tmp18_ - 10;
			break;
		}
		case DIRECTION_LEFT:
		{
			gint _tmp19_;
			gint _tmp20_;
			gint _tmp21_;
			gint _tmp22_;
			gint _tmp23_;
			_tmp19_ = x;
			_tmp20_ = length;
			self->xConnect = _tmp19_ - _tmp20_;
			_tmp21_ = y;
			self->yConnect = _tmp21_;
			_tmp22_ = x;
			self->xLabel = _tmp22_ + 10;
			_tmp23_ = y;
			self->yLabel = _tmp23_;
			break;
		}
		case DIRECTION_UP:
		{
			gint _tmp24_;
			gint _tmp25_;
			gint _tmp26_;
			gint _tmp27_;
			gint _tmp28_;
			_tmp24_ = x;
			self->xConnect = _tmp24_;
			_tmp25_ = y;
			_tmp26_ = length;
			self->yConnect = _tmp25_ - _tmp26_;
			_tmp27_ = x;
			self->xLabel = _tmp27_;
			_tmp28_ = y;
			self->yLabel = _tmp28_ + 10;
			break;
		}
		default:
		break;
	}
}


/**
 * Saves the PinDef to a file using libxml.
 */
void pin_def_save (PinDef* self, xmlTextWriter* xmlWriter, gint id) {
	xmlTextWriter* _tmp0_;
	xmlTextWriter* _tmp1_;
	gint _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	xmlTextWriter* _tmp5_;
	gint _tmp6_;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_;
	xmlTextWriter* _tmp9_;
	gint _tmp10_;
	gchar* _tmp11_ = NULL;
	gchar* _tmp12_;
	gchar* tmpString = NULL;
	Direction _tmp13_;
	xmlTextWriter* _tmp19_;
	const gchar* _tmp20_;
	xmlTextWriter* _tmp21_;
	gint _tmp22_;
	gchar* _tmp23_ = NULL;
	gchar* _tmp24_;
	Flow _tmp25_;
	PinDefLabelType _tmp29_;
	const gchar* _tmp35_ = NULL;
	gboolean _tmp36_;
	xmlTextWriter* _tmp37_;
	const gchar* _tmp38_;
	xmlTextWriter* _tmp39_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (xmlWriter != NULL);
	_tmp0_ = xmlWriter;
	xmlTextWriterStartElement (_tmp0_, "pin");
	_tmp1_ = xmlWriter;
	_tmp2_ = self->x;
	_tmp3_ = g_strdup_printf ("%i", _tmp2_);
	_tmp4_ = _tmp3_;
	xmlTextWriterWriteAttribute (_tmp1_, "x", _tmp4_);
	_g_free0 (_tmp4_);
	_tmp5_ = xmlWriter;
	_tmp6_ = self->y;
	_tmp7_ = g_strdup_printf ("%i", _tmp6_);
	_tmp8_ = _tmp7_;
	xmlTextWriterWriteAttribute (_tmp5_, "y", _tmp8_);
	_g_free0 (_tmp8_);
	_tmp9_ = xmlWriter;
	_tmp10_ = self->length;
	_tmp11_ = g_strdup_printf ("%i", _tmp10_);
	_tmp12_ = _tmp11_;
	xmlTextWriterWriteAttribute (_tmp9_, "length", _tmp12_);
	_g_free0 (_tmp12_);
	_tmp13_ = self->direction;
	switch (_tmp13_) {
		case DIRECTION_RIGHT:
		{
			gchar* _tmp14_;
			_tmp14_ = g_strdup ("right");
			_g_free0 (tmpString);
			tmpString = _tmp14_;
			break;
		}
		case DIRECTION_DOWN:
		{
			gchar* _tmp15_;
			_tmp15_ = g_strdup ("down");
			_g_free0 (tmpString);
			tmpString = _tmp15_;
			break;
		}
		case DIRECTION_LEFT:
		{
			gchar* _tmp16_;
			_tmp16_ = g_strdup ("left");
			_g_free0 (tmpString);
			tmpString = _tmp16_;
			break;
		}
		case DIRECTION_UP:
		{
			gchar* _tmp17_;
			_tmp17_ = g_strdup ("up");
			_g_free0 (tmpString);
			tmpString = _tmp17_;
			break;
		}
		default:
		{
			gchar* _tmp18_;
			_tmp18_ = g_strdup ("none");
			_g_free0 (tmpString);
			tmpString = _tmp18_;
			break;
		}
	}
	_tmp19_ = xmlWriter;
	_tmp20_ = tmpString;
	xmlTextWriterWriteAttribute (_tmp19_, "direction", _tmp20_);
	_tmp21_ = xmlWriter;
	_tmp22_ = id;
	_tmp23_ = g_strdup_printf ("%i", _tmp22_);
	_tmp24_ = _tmp23_;
	xmlTextWriterWriteAttribute (_tmp21_, "id", _tmp24_);
	_g_free0 (_tmp24_);
	_tmp25_ = self->flow;
	switch (_tmp25_) {
		case FLOW_IN:
		{
			xmlTextWriter* _tmp26_;
			_tmp26_ = xmlWriter;
			xmlTextWriterWriteAttribute (_tmp26_, "flow", "in");
			break;
		}
		case FLOW_OUT:
		{
			xmlTextWriter* _tmp27_;
			_tmp27_ = xmlWriter;
			xmlTextWriterWriteAttribute (_tmp27_, "flow", "out");
			break;
		}
		case FLOW_BIDIRECTIONAL:
		{
			xmlTextWriter* _tmp28_;
			_tmp28_ = xmlWriter;
			xmlTextWriterWriteAttribute (_tmp28_, "flow", "bi");
			break;
		}
		default:
		break;
	}
	_tmp29_ = self->labelType;
	switch (_tmp29_) {
		case PIN_DEF_LABEL_TYPE_TEXT:
		{
			xmlTextWriter* _tmp30_;
			const gchar* _tmp31_;
			_tmp30_ = xmlWriter;
			_tmp31_ = self->label;
			xmlTextWriterWriteAttribute (_tmp30_, "label", _tmp31_);
			break;
		}
		case PIN_DEF_LABEL_TYPE_TEXTBAR:
		{
			xmlTextWriter* _tmp32_;
			const gchar* _tmp33_;
			_tmp32_ = xmlWriter;
			_tmp33_ = self->label;
			xmlTextWriterWriteAttribute (_tmp32_, "barlabel", _tmp33_);
			break;
		}
		case PIN_DEF_LABEL_TYPE_CLOCK:
		{
			xmlTextWriter* _tmp34_;
			_tmp34_ = xmlWriter;
			xmlTextWriterWriteAttribute (_tmp34_, "symlabel", "clock");
			break;
		}
		default:
		break;
	}
	_tmp36_ = self->required;
	if (_tmp36_) {
		_tmp35_ = "true";
	} else {
		_tmp35_ = "false";
	}
	_tmp37_ = xmlWriter;
	_tmp38_ = _tmp35_;
	xmlTextWriterWriteAttribute (_tmp37_, "required", _tmp38_);
	_tmp39_ = xmlWriter;
	xmlTextWriterEndElement (_tmp39_);
	_g_free0 (tmpString);
}


/**
 * Renders the pin (without label). If //invert// is true, a small
 * circle is displayed on the start of the pin.
 */
void pin_def_render (PinDef* self, cairo_t* context, gboolean invert) {
	cairo_matrix_t oldmatrix = {0};
	cairo_t* _tmp0_;
	cairo_matrix_t _tmp1_ = {0};
	cairo_t* _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	Direction _tmp5_;
	cairo_t* _tmp19_;
	cairo_matrix_t _tmp20_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	_tmp0_ = context;
	cairo_get_matrix (_tmp0_, &_tmp1_);
	oldmatrix = _tmp1_;
	_tmp2_ = context;
	_tmp3_ = self->x;
	_tmp4_ = self->y;
	cairo_translate (_tmp2_, (gdouble) _tmp3_, (gdouble) _tmp4_);
	_tmp5_ = self->direction;
	if (_tmp5_ != DIRECTION_NONE) {
		gdouble angle;
		Direction _tmp6_;
		cairo_t* _tmp7_;
		gdouble _tmp8_;
		gboolean _tmp9_;
		angle = (gdouble) 0;
		_tmp6_ = self->direction;
		switch (_tmp6_) {
			case DIRECTION_RIGHT:
			{
				angle = (gdouble) 0;
				break;
			}
			case DIRECTION_DOWN:
			{
				angle = G_PI * 0.5;
				break;
			}
			case DIRECTION_LEFT:
			{
				angle = G_PI;
				break;
			}
			case DIRECTION_UP:
			{
				angle = G_PI * 1.5;
				break;
			}
			default:
			break;
		}
		_tmp7_ = context;
		_tmp8_ = angle;
		cairo_rotate (_tmp7_, _tmp8_);
		_tmp9_ = invert;
		if (_tmp9_) {
			cairo_t* _tmp10_;
			cairo_t* _tmp11_;
			gint _tmp12_;
			cairo_t* _tmp13_;
			cairo_t* _tmp14_;
			_tmp10_ = context;
			cairo_move_to (_tmp10_, (gdouble) 10, (gdouble) 0);
			_tmp11_ = context;
			_tmp12_ = self->length;
			cairo_line_to (_tmp11_, (gdouble) _tmp12_, (gdouble) 0);
			_tmp13_ = context;
			cairo_arc (_tmp13_, (gdouble) 5, (gdouble) 0, (gdouble) 5, (gdouble) 0, G_PI * 2);
			_tmp14_ = context;
			cairo_stroke (_tmp14_);
		} else {
			cairo_t* _tmp15_;
			cairo_t* _tmp16_;
			gint _tmp17_;
			cairo_t* _tmp18_;
			_tmp15_ = context;
			cairo_move_to (_tmp15_, (gdouble) 0, (gdouble) 0);
			_tmp16_ = context;
			_tmp17_ = self->length;
			cairo_line_to (_tmp16_, (gdouble) _tmp17_, (gdouble) 0);
			_tmp18_ = context;
			cairo_stroke (_tmp18_);
		}
	}
	_tmp19_ = context;
	_tmp20_ = oldmatrix;
	cairo_set_matrix (_tmp19_, &_tmp20_);
}


static void value_pin_def_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_pin_def_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		pin_def_unref (value->data[0].v_pointer);
	}
}


static void value_pin_def_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = pin_def_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_pin_def_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_pin_def_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		PinDef* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = pin_def_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_pin_def_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	PinDef** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = pin_def_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_pin_def (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecPinDef* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_PIN_DEF), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_pin_def (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PIN_DEF), NULL);
	return value->data[0].v_pointer;
}


void value_set_pin_def (GValue* value, gpointer v_object) {
	PinDef* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PIN_DEF));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_PIN_DEF));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		pin_def_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		pin_def_unref (old);
	}
}


void value_take_pin_def (GValue* value, gpointer v_object) {
	PinDef* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PIN_DEF));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_PIN_DEF));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		pin_def_unref (old);
	}
}


static void pin_def_class_init (PinDefClass * klass) {
	pin_def_parent_class = g_type_class_peek_parent (klass);
	PIN_DEF_CLASS (klass)->finalize = pin_def_finalize;
}


static void pin_def_instance_init (PinDef * self) {
	self->ref_count = 1;
}


static void pin_def_finalize (PinDef* obj) {
	PinDef * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PIN_DEF, PinDef);
	_g_free0 (self->label);
}


/**
 * Definition of a pin.
 * 
 * Used to describe how a pin should appear, and properties such as
 * required connections, and arrays.
 */
GType pin_def_get_type (void) {
	static volatile gsize pin_def_type_id__volatile = 0;
	if (g_once_init_enter (&pin_def_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_pin_def_init, value_pin_def_free_value, value_pin_def_copy_value, value_pin_def_peek_pointer, "p", value_pin_def_collect_value, "p", value_pin_def_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (PinDefClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) pin_def_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PinDef), 0, (GInstanceInitFunc) pin_def_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType pin_def_type_id;
		pin_def_type_id = g_type_register_fundamental (g_type_fundamental_next (), "PinDef", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&pin_def_type_id__volatile, pin_def_type_id);
	}
	return pin_def_type_id__volatile;
}


gpointer pin_def_ref (gpointer instance) {
	PinDef* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void pin_def_unref (gpointer instance) {
	PinDef* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		PIN_DEF_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



