/* timingdiagram.c generated by valac 0.20.1, the Vala compiler
 * generated from timingdiagram.vala, do not modify */

/* 
 * SmartSim - Digital Logic Circuit Designer and Simulator
 *   
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *   
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *   
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *   
 *   Filename: timingdiagram.vala
 *   
 *   Copyright Ashley Newson 2013
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <cairo.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <stdio.h>
#include <gdk/gdk.h>
#include <config.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <cairo-pdf.h>
#include <cairo-svg.h>


#define TYPE_TIMING_DIAGRAM (timing_diagram_get_type ())
#define TIMING_DIAGRAM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TIMING_DIAGRAM, TimingDiagram))
#define TIMING_DIAGRAM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TIMING_DIAGRAM, TimingDiagramClass))
#define IS_TIMING_DIAGRAM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TIMING_DIAGRAM))
#define IS_TIMING_DIAGRAM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TIMING_DIAGRAM))
#define TIMING_DIAGRAM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TIMING_DIAGRAM, TimingDiagramClass))

typedef struct _TimingDiagram TimingDiagram;
typedef struct _TimingDiagramClass TimingDiagramClass;
typedef struct _TimingDiagramPrivate TimingDiagramPrivate;

#define TYPE_WIRE_STATE (wire_state_get_type ())
#define WIRE_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_WIRE_STATE, WireState))
#define WIRE_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_WIRE_STATE, WireStateClass))
#define IS_WIRE_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_WIRE_STATE))
#define IS_WIRE_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_WIRE_STATE))
#define WIRE_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_WIRE_STATE, WireStateClass))

typedef struct _WireState WireState;
typedef struct _WireStateClass WireStateClass;

#define TIMING_DIAGRAM_TYPE_MOUSE_MODE (timing_diagram_mouse_mode_get_type ())

#define TYPE_COMPILED_CIRCUIT (compiled_circuit_get_type ())
#define COMPILED_CIRCUIT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMPILED_CIRCUIT, CompiledCircuit))
#define COMPILED_CIRCUIT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMPILED_CIRCUIT, CompiledCircuitClass))
#define IS_COMPILED_CIRCUIT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMPILED_CIRCUIT))
#define IS_COMPILED_CIRCUIT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMPILED_CIRCUIT))
#define COMPILED_CIRCUIT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMPILED_CIRCUIT, CompiledCircuitClass))

typedef struct _CompiledCircuit CompiledCircuit;
typedef struct _CompiledCircuitClass CompiledCircuitClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))
#define _compiled_circuit_unref0(var) ((var == NULL) ? NULL : (var = (compiled_circuit_unref (var), NULL)))
#define _wire_state_unref0(var) ((var == NULL) ? NULL : (var = (wire_state_unref (var), NULL)))

#define TYPE_PROPERTY_ITEM (property_item_get_type ())
#define PROPERTY_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROPERTY_ITEM, PropertyItem))
#define PROPERTY_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROPERTY_ITEM, PropertyItemClass))
#define IS_PROPERTY_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROPERTY_ITEM))
#define IS_PROPERTY_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROPERTY_ITEM))
#define PROPERTY_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROPERTY_ITEM, PropertyItemClass))

typedef struct _PropertyItem PropertyItem;
typedef struct _PropertyItemClass PropertyItemClass;

#define TYPE_PROPERTY_SET (property_set_get_type ())
#define PROPERTY_SET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROPERTY_SET, PropertySet))
#define PROPERTY_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROPERTY_SET, PropertySetClass))
#define IS_PROPERTY_SET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROPERTY_SET))
#define IS_PROPERTY_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROPERTY_SET))
#define PROPERTY_SET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROPERTY_SET, PropertySetClass))

typedef struct _PropertySet PropertySet;
typedef struct _PropertySetClass PropertySetClass;

#define TYPE_PROPERTY_ITEM_STRING (property_item_string_get_type ())
#define PROPERTY_ITEM_STRING(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROPERTY_ITEM_STRING, PropertyItemString))
#define PROPERTY_ITEM_STRING_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROPERTY_ITEM_STRING, PropertyItemStringClass))
#define IS_PROPERTY_ITEM_STRING(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROPERTY_ITEM_STRING))
#define IS_PROPERTY_ITEM_STRING_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROPERTY_ITEM_STRING))
#define PROPERTY_ITEM_STRING_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROPERTY_ITEM_STRING, PropertyItemStringClass))

typedef struct _PropertyItemString PropertyItemString;
typedef struct _PropertyItemStringClass PropertyItemStringClass;

#define TYPE_PROPERTIES_QUERY (properties_query_get_type ())
#define PROPERTIES_QUERY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROPERTIES_QUERY, PropertiesQuery))
#define PROPERTIES_QUERY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROPERTIES_QUERY, PropertiesQueryClass))
#define IS_PROPERTIES_QUERY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROPERTIES_QUERY))
#define IS_PROPERTIES_QUERY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROPERTIES_QUERY))
#define PROPERTIES_QUERY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROPERTIES_QUERY, PropertiesQueryClass))

typedef struct _PropertiesQuery PropertiesQuery;
typedef struct _PropertiesQueryClass PropertiesQueryClass;
typedef struct _PropertyItemPrivate PropertyItemPrivate;
typedef struct _PropertyItemStringPrivate PropertyItemStringPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _CompiledCircuitPrivate CompiledCircuitPrivate;

#define TYPE_COMPONENT_DEF (component_def_get_type ())
#define COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMPONENT_DEF, ComponentDef))
#define COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMPONENT_DEF, ComponentDefClass))
#define IS_COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMPONENT_DEF))
#define IS_COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMPONENT_DEF))
#define COMPONENT_DEF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMPONENT_DEF, ComponentDefClass))

typedef struct _ComponentDef ComponentDef;
typedef struct _ComponentDefClass ComponentDefClass;

#define TYPE_CUSTOM_COMPONENT_DEF (custom_component_def_get_type ())
#define CUSTOM_COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CUSTOM_COMPONENT_DEF, CustomComponentDef))
#define CUSTOM_COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CUSTOM_COMPONENT_DEF, CustomComponentDefClass))
#define IS_CUSTOM_COMPONENT_DEF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CUSTOM_COMPONENT_DEF))
#define IS_CUSTOM_COMPONENT_DEF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CUSTOM_COMPONENT_DEF))
#define CUSTOM_COMPONENT_DEF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CUSTOM_COMPONENT_DEF, CustomComponentDefClass))

typedef struct _CustomComponentDef CustomComponentDef;
typedef struct _CustomComponentDefClass CustomComponentDefClass;

#define TYPE_PROJECT (project_get_type ())
#define PROJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROJECT, Project))
#define PROJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROJECT, ProjectClass))
#define IS_PROJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROJECT))
#define IS_PROJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROJECT))
#define PROJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROJECT, ProjectClass))

typedef struct _Project Project;
typedef struct _ProjectClass ProjectClass;

#define TYPE_UPDATE_QUEUE (update_queue_get_type ())
#define UPDATE_QUEUE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_UPDATE_QUEUE, UpdateQueue))
#define UPDATE_QUEUE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_UPDATE_QUEUE, UpdateQueueClass))
#define IS_UPDATE_QUEUE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_UPDATE_QUEUE))
#define IS_UPDATE_QUEUE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_UPDATE_QUEUE))
#define UPDATE_QUEUE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_UPDATE_QUEUE, UpdateQueueClass))

typedef struct _UpdateQueue UpdateQueue;
typedef struct _UpdateQueueClass UpdateQueueClass;

#define TYPE_COMPONENT_STATE (component_state_get_type ())
#define COMPONENT_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMPONENT_STATE, ComponentState))
#define COMPONENT_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMPONENT_STATE, ComponentStateClass))
#define IS_COMPONENT_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMPONENT_STATE))
#define IS_COMPONENT_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMPONENT_STATE))
#define COMPONENT_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMPONENT_STATE, ComponentStateClass))

typedef struct _ComponentState ComponentState;
typedef struct _ComponentStateClass ComponentStateClass;
#define _properties_query_unref0(var) ((var == NULL) ? NULL : (var = (properties_query_unref (var), NULL)))
#define _property_item_unref0(var) ((var == NULL) ? NULL : (var = (property_item_unref (var), NULL)))
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))

#define IMAGE_EXPORTER_TYPE_IMAGE_FORMAT (image_exporter_image_format_get_type ())

struct _TimingDiagram {
	GtkWindow parent_instance;
	TimingDiagramPrivate * priv;
	gboolean alwaysOnTop;
};

struct _TimingDiagramClass {
	GtkWindowClass parent_class;
};

typedef enum  {
	TIMING_DIAGRAM_MOUSE_MODE_SCROLL,
	TIMING_DIAGRAM_MOUSE_MODE_ZOOM,
	TIMING_DIAGRAM_MOUSE_MODE_MOVE,
	TIMING_DIAGRAM_MOUSE_MODE_DELETE,
	TIMING_DIAGRAM_MOUSE_MODE_ADJUST
} TimingDiagramMouseMode;

struct _TimingDiagramPrivate {
	GtkBox* vBox;
	GtkMenuBar* menubar;
	GtkMenuItem* menuFile;
	GtkMenu* menuFileMenu;
	GtkMenuItem* menuFileExport;
	GtkMenu* menuFileExportMenu;
	GtkMenuItem* menuFileExportPng;
	GtkMenuItem* menuFileExportPdf;
	GtkMenuItem* menuFileExportSvg;
	GtkMenuItem* menuFileSeparator1;
	GtkMenuItem* menuFileExit;
	GtkMenuItem* menuRecording;
	GtkMenu* menuRecordingMenu;
	GtkMenuItem* menuRecordingReset;
	GtkMenuItem* menuView;
	GtkMenu* menuViewMenu;
	GtkCheckMenuItem* menuViewAlwaysontop;
	GtkMenuItem* menuViewSeparator1;
	GtkCheckMenuItem* menuViewShowgrid;
	GtkMenuItem* menuViewSeparator2;
	GtkMenuItem* menuViewReset;
	GtkToolbar* toolbar;
	GtkRadioToolButton* toolScroll;
	GtkImage* toolScrollImage;
	GtkRadioToolButton* toolZoom;
	GtkImage* toolZoomImage;
	GtkSeparatorToolItem* toolSeparator1;
	GtkRadioToolButton* toolMove;
	GtkImage* toolMoveImage;
	GtkRadioToolButton* toolDelete;
	GtkImage* toolDeleteImage;
	GtkRadioToolButton* toolAdjust;
	GtkImage* toolAdjustImage;
	GtkEventBox* controller;
	GtkDrawingArea* display;
	cairo_surface_t* diagramCache;
	cairo_surface_t* offScreenSurface;
	gint largestLengthCache;
	WireState** wireStates;
	gint wireStates_length1;
	gint _wireStates_size_;
	gchar** labels;
	gint labels_length1;
	gint _labels_size_;
	gint xMouseStart;
	gint yMouseStart;
	TimingDiagramMouseMode mouseMode;
	gboolean showGrid;
	gint xView;
	gint yView;
	gfloat xZoom;
	gfloat yZoom;
	gdouble barPosition;
	CompiledCircuit* compiledCircuit;
	gint iterationCountOffset;
};

struct _PropertyItem {
	GTypeInstance parent_instance;
	volatile int ref_count;
	PropertyItemPrivate * priv;
	gchar* name;
	gchar* description;
};

struct _PropertyItemClass {
	GTypeClass parent_class;
	void (*finalize) (PropertyItem *self);
	GtkWidget* (*create_widget) (PropertyItem* self);
	void (*read_widget) (PropertyItem* self, GtkWidget* propertyWidget);
};

struct _PropertyItemString {
	PropertyItem parent_instance;
	PropertyItemStringPrivate * priv;
	gchar* data;
};

struct _PropertyItemStringClass {
	PropertyItemClass parent_class;
};

struct _CompiledCircuit {
	GTypeInstance parent_instance;
	volatile int ref_count;
	CompiledCircuitPrivate * priv;
	CustomComponentDef* rootComponent;
	Project* project;
	UpdateQueue* renderWireStates;
	UpdateQueue* renderComponentStates;
	UpdateQueue* processWireStates;
	UpdateQueue* processComponentStates;
	CustomComponentDef* viewedComponent;
	gint iterationCount;
};

struct _CompiledCircuitClass {
	GTypeClass parent_class;
	void (*finalize) (CompiledCircuit *self);
};

typedef enum  {
	IMAGE_EXPORTER_IMAGE_FORMAT_PNG_RGB,
	IMAGE_EXPORTER_IMAGE_FORMAT_PNG_ARGB,
	IMAGE_EXPORTER_IMAGE_FORMAT_PDF,
	IMAGE_EXPORTER_IMAGE_FORMAT_SVG,
	IMAGE_EXPORTER_IMAGE_FORMAT_SVG_CLEAR
} ImageExporterImageFormat;

typedef void (*ImageExporterRenderer) (const gchar* filename, ImageExporterImageFormat imageFormat, gdouble resolution, void* user_data);

static gpointer timing_diagram_parent_class = NULL;

GType timing_diagram_get_type (void) G_GNUC_CONST;
gpointer wire_state_ref (gpointer instance);
void wire_state_unref (gpointer instance);
GParamSpec* param_spec_wire_state (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_wire_state (GValue* value, gpointer v_object);
void value_take_wire_state (GValue* value, gpointer v_object);
gpointer value_get_wire_state (const GValue* value);
GType wire_state_get_type (void) G_GNUC_CONST;
static GType timing_diagram_mouse_mode_get_type (void) G_GNUC_UNUSED;
gpointer compiled_circuit_ref (gpointer instance);
void compiled_circuit_unref (gpointer instance);
GParamSpec* param_spec_compiled_circuit (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_compiled_circuit (GValue* value, gpointer v_object);
void value_take_compiled_circuit (GValue* value, gpointer v_object);
gpointer value_get_compiled_circuit (const GValue* value);
GType compiled_circuit_get_type (void) G_GNUC_CONST;
#define TIMING_DIAGRAM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_TIMING_DIAGRAM, TimingDiagramPrivate))
enum  {
	TIMING_DIAGRAM_DUMMY_PROPERTY
};
TimingDiagram* timing_diagram_new (CompiledCircuit* compiledCircuit);
TimingDiagram* timing_diagram_construct (GType object_type, CompiledCircuit* compiledCircuit);
void timing_diagram_populate (TimingDiagram* self);
gboolean timing_diagram_hide_diagram (TimingDiagram* self);
static gboolean _timing_diagram_hide_diagram_gtk_widget_delete_event (GtkWidget* _sender, GdkEventAny* event, gpointer self);
#define CORE_programName "SmartSim"
void timing_diagram_export_png (TimingDiagram* self);
static void _timing_diagram_export_png_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
void timing_diagram_export_pdf (TimingDiagram* self);
static void _timing_diagram_export_pdf_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
void timing_diagram_export_svg (TimingDiagram* self);
static void _timing_diagram_export_svg_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void __lambda25_ (TimingDiagram* self);
static void ___lambda25__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void __lambda26_ (TimingDiagram* self);
void timing_diagram_reset_timings (TimingDiagram* self);
static void ___lambda26__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void __lambda27_ (TimingDiagram* self, GtkCheckMenuItem* menuItem);
static void ___lambda27__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self);
static void __lambda28_ (TimingDiagram* self, GtkCheckMenuItem* menuItem);
gboolean timing_diagram_render (TimingDiagram* self, gboolean fullRefresh, cairo_t* passedDisplayContext);
static void ___lambda28__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self);
static void __lambda29_ (TimingDiagram* self);
void timing_diagram_reset_view (TimingDiagram* self);
static void ___lambda29__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void __lambda30_ (TimingDiagram* self);
static void ___lambda30__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
static void __lambda31_ (TimingDiagram* self);
static void ___lambda31__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
static void __lambda32_ (TimingDiagram* self);
static void ___lambda32__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
static void __lambda33_ (TimingDiagram* self);
static void ___lambda33__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
static void __lambda34_ (TimingDiagram* self);
static void ___lambda34__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
static gboolean timing_diagram_mouse_down (TimingDiagram* self, GdkEventButton* event);
static gboolean _timing_diagram_mouse_down_gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static gboolean timing_diagram_mouse_move (TimingDiagram* self, GdkEventMotion* event);
static gboolean _timing_diagram_mouse_move_gtk_widget_motion_notify_event (GtkWidget* _sender, GdkEventMotion* event, gpointer self);
static gboolean timing_diagram_mouse_up (TimingDiagram* self, GdkEventButton* event);
static gboolean _timing_diagram_mouse_up_gtk_widget_button_release_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static gboolean __lambda35_ (TimingDiagram* self, cairo_t* context);
static gboolean ___lambda35__gtk_widget_draw (GtkWidget* _sender, cairo_t* cr, gpointer self);
static gboolean __lambda36_ (TimingDiagram* self);
static gboolean ___lambda36__gtk_widget_configure_event (GtkWidget* _sender, GdkEventConfigure* event, gpointer self);
void timing_diagram_close_diagram (TimingDiagram* self);
void timing_diagram_show_diagram (TimingDiagram* self);
void timing_diagram_add_wire (TimingDiagram* self, WireState* newWireState);
PropertySet* property_set_new (const gchar* name, const gchar* description);
PropertySet* property_set_construct (GType object_type, const gchar* name, const gchar* description);
gpointer property_item_ref (gpointer instance);
void property_item_unref (gpointer instance);
GParamSpec* param_spec_property_item (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_property_item (GValue* value, gpointer v_object);
void value_take_property_item (GValue* value, gpointer v_object);
gpointer value_get_property_item (const GValue* value);
GType property_item_get_type (void) G_GNUC_CONST;
GType property_set_get_type (void) G_GNUC_CONST;
PropertyItemString* property_item_string_new (const gchar* name, const gchar* description, const gchar* data);
PropertyItemString* property_item_string_construct (GType object_type, const gchar* name, const gchar* description, const gchar* data);
GType property_item_string_get_type (void) G_GNUC_CONST;
gint property_set_add_item (PropertySet* self, PropertyItem* propertyItem);
PropertiesQuery* properties_query_new (const gchar* title, GtkWindow* parent, PropertySet* propertySet);
PropertiesQuery* properties_query_construct (GType object_type, const gchar* title, GtkWindow* parent, PropertySet* propertySet);
gpointer properties_query_ref (gpointer instance);
void properties_query_unref (gpointer instance);
GParamSpec* param_spec_properties_query (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_properties_query (GValue* value, gpointer v_object);
void value_take_properties_query (GValue* value, gpointer v_object);
gpointer value_get_properties_query (const GValue* value);
GType properties_query_get_type (void) G_GNUC_CONST;
gint properties_query_run (PropertiesQuery* self);
static void _vala_array_add110 (WireState*** array, int* length, int* size, WireState* value);
static void _vala_array_add111 (gchar*** array, int* length, int* size, gchar* value);
static void _vala_array_add112 (gchar*** array, int* length, int* size, gchar* value);
void wire_state_start_recording (WireState* self, gint unknownTime);
gpointer component_def_ref (gpointer instance);
void component_def_unref (gpointer instance);
GParamSpec* param_spec_component_def (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_component_def (GValue* value, gpointer v_object);
void value_take_component_def (GValue* value, gpointer v_object);
gpointer value_get_component_def (const GValue* value);
GType component_def_get_type (void) G_GNUC_CONST;
GType custom_component_def_get_type (void) G_GNUC_CONST;
gpointer project_ref (gpointer instance);
void project_unref (gpointer instance);
GParamSpec* param_spec_project (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_project (GValue* value, gpointer v_object);
void value_take_project (GValue* value, gpointer v_object);
gpointer value_get_project (const GValue* value);
GType project_get_type (void) G_GNUC_CONST;
gpointer update_queue_ref (gpointer instance);
void update_queue_unref (gpointer instance);
GParamSpec* param_spec_update_queue (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_update_queue (GValue* value, gpointer v_object);
void value_take_update_queue (GValue* value, gpointer v_object);
gpointer value_get_update_queue (const GValue* value);
GType update_queue_get_type (void) G_GNUC_CONST;
gpointer component_state_ref (gpointer instance);
void component_state_unref (gpointer instance);
GParamSpec* param_spec_component_state (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_component_state (GValue* value, gpointer v_object);
void value_take_component_state (GValue* value, gpointer v_object);
gpointer value_get_component_state (const GValue* value);
GType component_state_get_type (void) G_GNUC_CONST;
static void timing_diagram_forget_wire (TimingDiagram* self, gint wireNumber);
static void _vala_array_add113 (WireState*** array, int* length, int* size, WireState* value);
static void _vala_array_add114 (gchar*** array, int* length, int* size, gchar* value);
void wire_state_stop_recording (WireState* self);
static WireState** _vala_array_dup94 (WireState** self, int length);
static gchar** _vala_array_dup95 (gchar** self, int length);
static void timing_diagram_move_wire (TimingDiagram* self, gint fromNumber, gint toNumber);
static void _vala_array_add115 (WireState*** array, int* length, int* size, WireState* value);
static void _vala_array_add116 (gchar*** array, int* length, int* size, gchar* value);
static void _vala_array_add117 (WireState*** array, int* length, int* size, WireState* value);
static void _vala_array_add118 (gchar*** array, int* length, int* size, gchar* value);
static void _vala_array_add119 (WireState*** array, int* length, int* size, WireState* value);
static void _vala_array_add120 (gchar*** array, int* length, int* size, gchar* value);
static WireState** _vala_array_dup96 (WireState** self, int length);
static gchar** _vala_array_dup97 (gchar** self, int length);
static void timing_diagram_adjust_wire (TimingDiagram* self, gint wireNumber);
gint timing_diagram_text_length (TimingDiagram* self);
void timing_diagram_render_labels (TimingDiagram* self, cairo_t* context, gboolean fullRender, gint width, gint* largestLength);
void timing_diagram_render_graphs (TimingDiagram* self, cairo_t* context, gboolean fullRender, gint width, gint largestLength);
void wire_state_render_history (WireState* self, cairo_t* context, gint xStart, gint xEnd, gfloat height, gfloat stretch);
void timing_diagram_render_ruler (TimingDiagram* self, cairo_t* context, gboolean fullRender, gint width, gint height, gint largestLength);
static void timing_diagram_render_bar (TimingDiagram* self, cairo_t* context, gint height, gint largestLength);
GType image_exporter_image_format_get_type (void) G_GNUC_CONST;
void image_exporter_export_png (ImageExporterRenderer renderer, void* renderer_target);
static void timing_diagram_file_render (TimingDiagram* self, const gchar* filename, ImageExporterImageFormat imageFormat, gdouble resolution);
static void _timing_diagram_file_render_image_exporter_renderer (const gchar* filename, ImageExporterImageFormat imageFormat, gdouble resolution, gpointer self);
void image_exporter_export_pdf (ImageExporterRenderer renderer, void* renderer_target);
void image_exporter_export_svg (ImageExporterRenderer renderer, void* renderer_target);
static void timing_diagram_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


/**
 * Actions to perform when the mouse button is released.
 */
static GType timing_diagram_mouse_mode_get_type (void) {
	static volatile gsize timing_diagram_mouse_mode_type_id__volatile = 0;
	if (g_once_init_enter (&timing_diagram_mouse_mode_type_id__volatile)) {
		static const GEnumValue values[] = {{TIMING_DIAGRAM_MOUSE_MODE_SCROLL, "TIMING_DIAGRAM_MOUSE_MODE_SCROLL", "scroll"}, {TIMING_DIAGRAM_MOUSE_MODE_ZOOM, "TIMING_DIAGRAM_MOUSE_MODE_ZOOM", "zoom"}, {TIMING_DIAGRAM_MOUSE_MODE_MOVE, "TIMING_DIAGRAM_MOUSE_MODE_MOVE", "move"}, {TIMING_DIAGRAM_MOUSE_MODE_DELETE, "TIMING_DIAGRAM_MOUSE_MODE_DELETE", "delete"}, {TIMING_DIAGRAM_MOUSE_MODE_ADJUST, "TIMING_DIAGRAM_MOUSE_MODE_ADJUST", "adjust"}, {0, NULL, NULL}};
		GType timing_diagram_mouse_mode_type_id;
		timing_diagram_mouse_mode_type_id = g_enum_register_static ("TimingDiagramMouseMode", values);
		g_once_init_leave (&timing_diagram_mouse_mode_type_id__volatile, timing_diagram_mouse_mode_type_id);
	}
	return timing_diagram_mouse_mode_type_id__volatile;
}


static gpointer _compiled_circuit_ref0 (gpointer self) {
	return self ? compiled_circuit_ref (self) : NULL;
}


TimingDiagram* timing_diagram_construct (GType object_type, CompiledCircuit* compiledCircuit) {
	TimingDiagram * self = NULL;
	CompiledCircuit* _tmp0_;
	CompiledCircuit* _tmp1_;
	g_return_val_if_fail (compiledCircuit != NULL, NULL);
	self = (TimingDiagram*) g_object_new (object_type, NULL);
	_tmp0_ = compiledCircuit;
	_tmp1_ = _compiled_circuit_ref0 (_tmp0_);
	_compiled_circuit_unref0 (self->priv->compiledCircuit);
	self->priv->compiledCircuit = _tmp1_;
	timing_diagram_populate (self);
	return self;
}


TimingDiagram* timing_diagram_new (CompiledCircuit* compiledCircuit) {
	return timing_diagram_construct (TYPE_TIMING_DIAGRAM, compiledCircuit);
}


/**
 * Populate the window with widgets.
 */
static gboolean _timing_diagram_hide_diagram_gtk_widget_delete_event (GtkWidget* _sender, GdkEventAny* event, gpointer self) {
	gboolean result;
	result = timing_diagram_hide_diagram (self);
	return result;
}


static void _timing_diagram_export_png_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	timing_diagram_export_png (self);
}


static void _timing_diagram_export_pdf_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	timing_diagram_export_pdf (self);
}


static void _timing_diagram_export_svg_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	timing_diagram_export_svg (self);
}


static void __lambda25_ (TimingDiagram* self) {
	timing_diagram_hide_diagram (self);
}


static void ___lambda25__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	__lambda25_ (self);
}


static void __lambda26_ (TimingDiagram* self) {
	timing_diagram_reset_timings (self);
}


static void ___lambda26__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	__lambda26_ (self);
}


static void __lambda27_ (TimingDiagram* self, GtkCheckMenuItem* menuItem) {
	GtkCheckMenuItem* _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	GtkCheckMenuItem* _tmp3_;
	gboolean _tmp4_;
	gboolean _tmp5_;
	g_return_if_fail (menuItem != NULL);
	_tmp0_ = menuItem;
	_tmp1_ = gtk_check_menu_item_get_active (_tmp0_);
	_tmp2_ = _tmp1_;
	gtk_window_set_keep_above ((GtkWindow*) self, _tmp2_);
	_tmp3_ = menuItem;
	_tmp4_ = gtk_check_menu_item_get_active (_tmp3_);
	_tmp5_ = _tmp4_;
	self->alwaysOnTop = _tmp5_;
}


static void ___lambda27__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self) {
	__lambda27_ (self, _sender);
}


static void __lambda28_ (TimingDiagram* self, GtkCheckMenuItem* menuItem) {
	GtkCheckMenuItem* _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	g_return_if_fail (menuItem != NULL);
	_tmp0_ = menuItem;
	_tmp1_ = gtk_check_menu_item_get_active (_tmp0_);
	_tmp2_ = _tmp1_;
	self->priv->showGrid = _tmp2_;
	_cairo_surface_destroy0 (self->priv->diagramCache);
	self->priv->diagramCache = NULL;
	timing_diagram_render (self, TRUE, NULL);
}


static void ___lambda28__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self) {
	__lambda28_ (self, _sender);
}


static void __lambda29_ (TimingDiagram* self) {
	timing_diagram_reset_view (self);
}


static void ___lambda29__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	__lambda29_ (self);
}


static void __lambda30_ (TimingDiagram* self) {
	self->priv->mouseMode = TIMING_DIAGRAM_MOUSE_MODE_SCROLL;
}


static void ___lambda30__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	__lambda30_ (self);
}


static void __lambda31_ (TimingDiagram* self) {
	self->priv->mouseMode = TIMING_DIAGRAM_MOUSE_MODE_ZOOM;
}


static void ___lambda31__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	__lambda31_ (self);
}


static void __lambda32_ (TimingDiagram* self) {
	self->priv->mouseMode = TIMING_DIAGRAM_MOUSE_MODE_MOVE;
}


static void ___lambda32__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	__lambda32_ (self);
}


static void __lambda33_ (TimingDiagram* self) {
	self->priv->mouseMode = TIMING_DIAGRAM_MOUSE_MODE_DELETE;
}


static void ___lambda33__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	__lambda33_ (self);
}


static void __lambda34_ (TimingDiagram* self) {
	self->priv->mouseMode = TIMING_DIAGRAM_MOUSE_MODE_ADJUST;
}


static void ___lambda34__gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	__lambda34_ (self);
}


static gboolean _timing_diagram_mouse_down_gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = timing_diagram_mouse_down (self, event);
	return result;
}


static gboolean _timing_diagram_mouse_move_gtk_widget_motion_notify_event (GtkWidget* _sender, GdkEventMotion* event, gpointer self) {
	gboolean result;
	result = timing_diagram_mouse_move (self, event);
	return result;
}


static gboolean _timing_diagram_mouse_up_gtk_widget_button_release_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = timing_diagram_mouse_up (self, event);
	return result;
}


static gboolean __lambda35_ (TimingDiagram* self, cairo_t* context) {
	gboolean result = FALSE;
	cairo_t* _tmp0_;
	g_return_val_if_fail (context != NULL, FALSE);
	_tmp0_ = context;
	timing_diagram_render (self, TRUE, _tmp0_);
	result = FALSE;
	return result;
}


static gboolean ___lambda35__gtk_widget_draw (GtkWidget* _sender, cairo_t* cr, gpointer self) {
	gboolean result;
	result = __lambda35_ (self, cr);
	return result;
}


static gboolean __lambda36_ (TimingDiagram* self) {
	gboolean result = FALSE;
	_cairo_surface_destroy0 (self->priv->diagramCache);
	self->priv->diagramCache = NULL;
	timing_diagram_render (self, TRUE, NULL);
	result = FALSE;
	return result;
}


static gboolean ___lambda36__gtk_widget_configure_event (GtkWidget* _sender, GdkEventConfigure* event, gpointer self) {
	gboolean result;
	result = __lambda36_ (self);
	return result;
}


void timing_diagram_populate (TimingDiagram* self) {
	FILE* _tmp0_;
	GtkBox* _tmp5_;
	GtkBox* _tmp6_;
	GtkMenuBar* _tmp7_;
	GtkBox* _tmp8_;
	GtkMenuBar* _tmp9_;
	GtkMenuItem* _tmp10_;
	GtkMenuBar* _tmp11_;
	GtkMenuItem* _tmp12_;
	GtkMenu* _tmp13_;
	GtkMenuItem* _tmp14_;
	GtkMenu* _tmp15_;
	GtkMenuItem* _tmp16_;
	GtkMenu* _tmp17_;
	GtkMenuItem* _tmp18_;
	GtkMenu* _tmp19_;
	GtkMenuItem* _tmp20_;
	GtkMenu* _tmp21_;
	GtkMenuItem* _tmp22_;
	GtkMenu* _tmp23_;
	GtkMenuItem* _tmp24_;
	GtkMenuItem* _tmp25_;
	GtkMenuItem* _tmp26_;
	GtkMenu* _tmp27_;
	GtkMenuItem* _tmp28_;
	GtkMenuItem* _tmp29_;
	GtkMenuItem* _tmp30_;
	GtkMenu* _tmp31_;
	GtkMenuItem* _tmp32_;
	GtkMenuItem* _tmp33_;
	GtkSeparatorMenuItem* _tmp34_;
	GtkMenu* _tmp35_;
	GtkMenuItem* _tmp36_;
	GtkMenuItem* _tmp37_;
	GtkMenu* _tmp38_;
	GtkMenuItem* _tmp39_;
	GtkMenuItem* _tmp40_;
	GtkMenuItem* _tmp41_;
	GtkMenuBar* _tmp42_;
	GtkMenuItem* _tmp43_;
	GtkMenu* _tmp44_;
	GtkMenuItem* _tmp45_;
	GtkMenu* _tmp46_;
	GtkMenuItem* _tmp47_;
	GtkMenu* _tmp48_;
	GtkMenuItem* _tmp49_;
	GtkMenuItem* _tmp50_;
	GtkMenuItem* _tmp51_;
	GtkMenuBar* _tmp52_;
	GtkMenuItem* _tmp53_;
	GtkMenu* _tmp54_;
	GtkMenuItem* _tmp55_;
	GtkMenu* _tmp56_;
	GtkCheckMenuItem* _tmp57_;
	GtkMenu* _tmp58_;
	GtkCheckMenuItem* _tmp59_;
	GtkCheckMenuItem* _tmp60_;
	GtkCheckMenuItem* _tmp61_;
	GtkSeparatorMenuItem* _tmp62_;
	GtkMenu* _tmp63_;
	GtkMenuItem* _tmp64_;
	GtkCheckMenuItem* _tmp65_;
	GtkMenu* _tmp66_;
	GtkCheckMenuItem* _tmp67_;
	GtkCheckMenuItem* _tmp68_;
	GtkCheckMenuItem* _tmp69_;
	GtkSeparatorMenuItem* _tmp70_;
	GtkMenu* _tmp71_;
	GtkMenuItem* _tmp72_;
	GtkMenuItem* _tmp73_;
	GtkMenu* _tmp74_;
	GtkMenuItem* _tmp75_;
	GtkMenuItem* _tmp76_;
	GtkToolbar* _tmp77_;
	GtkToolbar* _tmp78_;
	GtkBox* _tmp79_;
	GtkToolbar* _tmp80_;
	GtkImage* _tmp81_;
	GtkRadioToolButton* _tmp82_;
	GtkRadioToolButton* _tmp83_;
	GtkRadioToolButton* _tmp84_;
	GtkImage* _tmp85_;
	GtkToolbar* _tmp86_;
	GtkRadioToolButton* _tmp87_;
	GtkRadioToolButton* _tmp88_;
	GtkRadioToolButton* _tmp89_;
	GtkImage* _tmp90_;
	GtkRadioToolButton* _tmp91_;
	GtkRadioToolButton* _tmp92_;
	GtkRadioToolButton* _tmp93_;
	GtkRadioToolButton* _tmp94_;
	GtkImage* _tmp95_;
	GtkToolbar* _tmp96_;
	GtkRadioToolButton* _tmp97_;
	GtkRadioToolButton* _tmp98_;
	GtkRadioToolButton* _tmp99_;
	GtkSeparatorToolItem* _tmp100_;
	GtkToolbar* _tmp101_;
	GtkSeparatorToolItem* _tmp102_;
	GtkImage* _tmp103_;
	GtkRadioToolButton* _tmp104_;
	GtkRadioToolButton* _tmp105_;
	GtkRadioToolButton* _tmp106_;
	GtkRadioToolButton* _tmp107_;
	GtkImage* _tmp108_;
	GtkToolbar* _tmp109_;
	GtkRadioToolButton* _tmp110_;
	GtkRadioToolButton* _tmp111_;
	GtkRadioToolButton* _tmp112_;
	GtkImage* _tmp113_;
	GtkRadioToolButton* _tmp114_;
	GtkRadioToolButton* _tmp115_;
	GtkRadioToolButton* _tmp116_;
	GtkRadioToolButton* _tmp117_;
	GtkImage* _tmp118_;
	GtkToolbar* _tmp119_;
	GtkRadioToolButton* _tmp120_;
	GtkRadioToolButton* _tmp121_;
	GtkRadioToolButton* _tmp122_;
	GtkImage* _tmp123_;
	GtkRadioToolButton* _tmp124_;
	GtkRadioToolButton* _tmp125_;
	GtkRadioToolButton* _tmp126_;
	GtkRadioToolButton* _tmp127_;
	GtkImage* _tmp128_;
	GtkToolbar* _tmp129_;
	GtkRadioToolButton* _tmp130_;
	GtkRadioToolButton* _tmp131_;
	GtkRadioToolButton* _tmp132_;
	GtkEventBox* _tmp133_;
	GtkBox* _tmp134_;
	GtkEventBox* _tmp135_;
	GtkEventBox* _tmp136_;
	GtkEventBox* _tmp137_;
	GtkEventBox* _tmp138_;
	GtkEventBox* _tmp139_;
	GtkDrawingArea* _tmp140_;
	GtkEventBox* _tmp141_;
	GtkDrawingArea* _tmp142_;
	GtkDrawingArea* _tmp143_;
	GtkDrawingArea* _tmp144_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = stdout;
	fprintf (_tmp0_, "Timing Diagram Window Created\n");
	gtk_window_set_default_size ((GtkWindow*) self, 800, 400);
	gtk_container_set_border_width ((GtkContainer*) self, (guint) 0);
	g_signal_connect_object ((GtkWidget*) self, "delete-event", (GCallback) _timing_diagram_hide_diagram_gtk_widget_delete_event, self, 0);
	gtk_window_set_title ((GtkWindow*) self, CORE_programName " - Timing Diagram");
	{
		GdkPixbuf* _tmp1_;
		GdkPixbuf* _tmp2_;
		GdkPixbuf* _tmp3_;
		_tmp1_ = gdk_pixbuf_new_from_file (PACKAGE_DATADIR "images/icons/smartsim64.png", &_inner_error_);
		_tmp2_ = _tmp1_;
		if (_inner_error_ != NULL) {
			goto __catch71_g_error;
		}
		_tmp3_ = _tmp2_;
		gtk_window_set_icon ((GtkWindow*) self, _tmp3_);
		_g_object_unref0 (_tmp3_);
	}
	goto __finally71;
	__catch71_g_error:
	{
		FILE* _tmp4_;
		g_clear_error (&_inner_error_);
		_inner_error_ = NULL;
		_tmp4_ = stderr;
		fprintf (_tmp4_, "Could not load window image.\n");
	}
	__finally71:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp5_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 2);
	g_object_ref_sink (_tmp5_);
	_g_object_unref0 (self->priv->vBox);
	self->priv->vBox = _tmp5_;
	_tmp6_ = self->priv->vBox;
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) _tmp6_);
	_tmp7_ = (GtkMenuBar*) gtk_menu_bar_new ();
	g_object_ref_sink (_tmp7_);
	_g_object_unref0 (self->priv->menubar);
	self->priv->menubar = _tmp7_;
	_tmp8_ = self->priv->vBox;
	_tmp9_ = self->priv->menubar;
	gtk_box_pack_start (_tmp8_, (GtkWidget*) _tmp9_, FALSE, TRUE, (guint) 0);
	_tmp10_ = (GtkMenuItem*) gtk_menu_item_new_with_label ("File");
	g_object_ref_sink (_tmp10_);
	_g_object_unref0 (self->priv->menuFile);
	self->priv->menuFile = _tmp10_;
	_tmp11_ = self->priv->menubar;
	_tmp12_ = self->priv->menuFile;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp11_, (GtkWidget*) _tmp12_);
	_tmp13_ = (GtkMenu*) gtk_menu_new ();
	g_object_ref_sink (_tmp13_);
	_g_object_unref0 (self->priv->menuFileMenu);
	self->priv->menuFileMenu = _tmp13_;
	_tmp14_ = self->priv->menuFile;
	_tmp15_ = self->priv->menuFileMenu;
	gtk_menu_item_set_submenu (_tmp14_, (GtkWidget*) _tmp15_);
	_tmp16_ = (GtkMenuItem*) gtk_menu_item_new_with_label ("Export");
	g_object_ref_sink (_tmp16_);
	_g_object_unref0 (self->priv->menuFileExport);
	self->priv->menuFileExport = _tmp16_;
	_tmp17_ = self->priv->menuFileMenu;
	_tmp18_ = self->priv->menuFileExport;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp17_, (GtkWidget*) _tmp18_);
	_tmp19_ = (GtkMenu*) gtk_menu_new ();
	g_object_ref_sink (_tmp19_);
	_g_object_unref0 (self->priv->menuFileExportMenu);
	self->priv->menuFileExportMenu = _tmp19_;
	_tmp20_ = self->priv->menuFileExport;
	_tmp21_ = self->priv->menuFileExportMenu;
	gtk_menu_item_set_submenu (_tmp20_, (GtkWidget*) _tmp21_);
	_tmp22_ = (GtkMenuItem*) gtk_menu_item_new_with_label ("Diagram Image as PNG Image");
	g_object_ref_sink (_tmp22_);
	_g_object_unref0 (self->priv->menuFileExportPng);
	self->priv->menuFileExportPng = _tmp22_;
	_tmp23_ = self->priv->menuFileExportMenu;
	_tmp24_ = self->priv->menuFileExportPng;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp23_, (GtkWidget*) _tmp24_);
	_tmp25_ = self->priv->menuFileExportPng;
	g_signal_connect_object (_tmp25_, "activate", (GCallback) _timing_diagram_export_png_gtk_menu_item_activate, self, 0);
	_tmp26_ = (GtkMenuItem*) gtk_menu_item_new_with_label ("Diagram Image as PDF Document");
	g_object_ref_sink (_tmp26_);
	_g_object_unref0 (self->priv->menuFileExportPdf);
	self->priv->menuFileExportPdf = _tmp26_;
	_tmp27_ = self->priv->menuFileExportMenu;
	_tmp28_ = self->priv->menuFileExportPdf;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp27_, (GtkWidget*) _tmp28_);
	_tmp29_ = self->priv->menuFileExportPdf;
	g_signal_connect_object (_tmp29_, "activate", (GCallback) _timing_diagram_export_pdf_gtk_menu_item_activate, self, 0);
	_tmp30_ = (GtkMenuItem*) gtk_menu_item_new_with_label ("Diagram Image as SVG Image");
	g_object_ref_sink (_tmp30_);
	_g_object_unref0 (self->priv->menuFileExportSvg);
	self->priv->menuFileExportSvg = _tmp30_;
	_tmp31_ = self->priv->menuFileExportMenu;
	_tmp32_ = self->priv->menuFileExportSvg;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp31_, (GtkWidget*) _tmp32_);
	_tmp33_ = self->priv->menuFileExportSvg;
	g_signal_connect_object (_tmp33_, "activate", (GCallback) _timing_diagram_export_svg_gtk_menu_item_activate, self, 0);
	_tmp34_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
	g_object_ref_sink (_tmp34_);
	_g_object_unref0 (self->priv->menuFileSeparator1);
	self->priv->menuFileSeparator1 = (GtkMenuItem*) _tmp34_;
	_tmp35_ = self->priv->menuFileMenu;
	_tmp36_ = self->priv->menuFileSeparator1;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp35_, (GtkWidget*) _tmp36_);
	_tmp37_ = (GtkMenuItem*) gtk_menu_item_new_with_label ("Close Timing Diagram");
	g_object_ref_sink (_tmp37_);
	_g_object_unref0 (self->priv->menuFileExit);
	self->priv->menuFileExit = _tmp37_;
	_tmp38_ = self->priv->menuFileMenu;
	_tmp39_ = self->priv->menuFileExit;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp38_, (GtkWidget*) _tmp39_);
	_tmp40_ = self->priv->menuFileExit;
	g_signal_connect_object (_tmp40_, "activate", (GCallback) ___lambda25__gtk_menu_item_activate, self, 0);
	_tmp41_ = (GtkMenuItem*) gtk_menu_item_new_with_label ("Recording");
	g_object_ref_sink (_tmp41_);
	_g_object_unref0 (self->priv->menuRecording);
	self->priv->menuRecording = _tmp41_;
	_tmp42_ = self->priv->menubar;
	_tmp43_ = self->priv->menuRecording;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp42_, (GtkWidget*) _tmp43_);
	_tmp44_ = (GtkMenu*) gtk_menu_new ();
	g_object_ref_sink (_tmp44_);
	_g_object_unref0 (self->priv->menuRecordingMenu);
	self->priv->menuRecordingMenu = _tmp44_;
	_tmp45_ = self->priv->menuRecording;
	_tmp46_ = self->priv->menuRecordingMenu;
	gtk_menu_item_set_submenu (_tmp45_, (GtkWidget*) _tmp46_);
	_tmp47_ = (GtkMenuItem*) gtk_menu_item_new_with_label ("Reset");
	g_object_ref_sink (_tmp47_);
	_g_object_unref0 (self->priv->menuRecordingReset);
	self->priv->menuRecordingReset = _tmp47_;
	_tmp48_ = self->priv->menuRecordingMenu;
	_tmp49_ = self->priv->menuRecordingReset;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp48_, (GtkWidget*) _tmp49_);
	_tmp50_ = self->priv->menuRecordingReset;
	g_signal_connect_object (_tmp50_, "activate", (GCallback) ___lambda26__gtk_menu_item_activate, self, 0);
	_tmp51_ = (GtkMenuItem*) gtk_menu_item_new_with_label ("View");
	g_object_ref_sink (_tmp51_);
	_g_object_unref0 (self->priv->menuView);
	self->priv->menuView = _tmp51_;
	_tmp52_ = self->priv->menubar;
	_tmp53_ = self->priv->menuView;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp52_, (GtkWidget*) _tmp53_);
	_tmp54_ = (GtkMenu*) gtk_menu_new ();
	g_object_ref_sink (_tmp54_);
	_g_object_unref0 (self->priv->menuViewMenu);
	self->priv->menuViewMenu = _tmp54_;
	_tmp55_ = self->priv->menuView;
	_tmp56_ = self->priv->menuViewMenu;
	gtk_menu_item_set_submenu (_tmp55_, (GtkWidget*) _tmp56_);
	_tmp57_ = (GtkCheckMenuItem*) gtk_check_menu_item_new_with_label ("Always On Top");
	g_object_ref_sink (_tmp57_);
	_g_object_unref0 (self->priv->menuViewAlwaysontop);
	self->priv->menuViewAlwaysontop = _tmp57_;
	_tmp58_ = self->priv->menuViewMenu;
	_tmp59_ = self->priv->menuViewAlwaysontop;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp58_, (GtkWidget*) ((GtkMenuItem*) _tmp59_));
	_tmp60_ = self->priv->menuViewAlwaysontop;
	gtk_check_menu_item_set_active (_tmp60_, TRUE);
	_tmp61_ = self->priv->menuViewAlwaysontop;
	g_signal_connect_object (_tmp61_, "toggled", (GCallback) ___lambda27__gtk_check_menu_item_toggled, self, 0);
	_tmp62_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
	g_object_ref_sink (_tmp62_);
	_g_object_unref0 (self->priv->menuViewSeparator1);
	self->priv->menuViewSeparator1 = (GtkMenuItem*) _tmp62_;
	_tmp63_ = self->priv->menuViewMenu;
	_tmp64_ = self->priv->menuViewSeparator1;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp63_, (GtkWidget*) _tmp64_);
	_tmp65_ = (GtkCheckMenuItem*) gtk_check_menu_item_new_with_label ("Show Grid");
	g_object_ref_sink (_tmp65_);
	_g_object_unref0 (self->priv->menuViewShowgrid);
	self->priv->menuViewShowgrid = _tmp65_;
	_tmp66_ = self->priv->menuViewMenu;
	_tmp67_ = self->priv->menuViewShowgrid;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp66_, (GtkWidget*) ((GtkMenuItem*) _tmp67_));
	_tmp68_ = self->priv->menuViewShowgrid;
	gtk_check_menu_item_set_active (_tmp68_, TRUE);
	_tmp69_ = self->priv->menuViewShowgrid;
	g_signal_connect_object (_tmp69_, "toggled", (GCallback) ___lambda28__gtk_check_menu_item_toggled, self, 0);
	_tmp70_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
	g_object_ref_sink (_tmp70_);
	_g_object_unref0 (self->priv->menuViewSeparator2);
	self->priv->menuViewSeparator2 = (GtkMenuItem*) _tmp70_;
	_tmp71_ = self->priv->menuViewMenu;
	_tmp72_ = self->priv->menuViewSeparator2;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp71_, (GtkWidget*) _tmp72_);
	_tmp73_ = (GtkMenuItem*) gtk_menu_item_new_with_label ("Reset View");
	g_object_ref_sink (_tmp73_);
	_g_object_unref0 (self->priv->menuViewReset);
	self->priv->menuViewReset = _tmp73_;
	_tmp74_ = self->priv->menuViewMenu;
	_tmp75_ = self->priv->menuViewReset;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp74_, (GtkWidget*) _tmp75_);
	_tmp76_ = self->priv->menuViewReset;
	g_signal_connect_object (_tmp76_, "activate", (GCallback) ___lambda29__gtk_menu_item_activate, self, 0);
	_tmp77_ = (GtkToolbar*) gtk_toolbar_new ();
	g_object_ref_sink (_tmp77_);
	_g_object_unref0 (self->priv->toolbar);
	self->priv->toolbar = _tmp77_;
	_tmp78_ = self->priv->toolbar;
	g_object_set (_tmp78_, "toolbar-style", GTK_TOOLBAR_ICONS, NULL);
	_tmp79_ = self->priv->vBox;
	_tmp80_ = self->priv->toolbar;
	gtk_box_pack_start (_tmp79_, (GtkWidget*) _tmp80_, FALSE, TRUE, (guint) 0);
	_tmp81_ = (GtkImage*) gtk_image_new_from_file (PACKAGE_DATADIR "images/toolbar/scroll.png");
	g_object_ref_sink (_tmp81_);
	_g_object_unref0 (self->priv->toolScrollImage);
	self->priv->toolScrollImage = _tmp81_;
	_tmp82_ = (GtkRadioToolButton*) gtk_radio_tool_button_new (NULL);
	g_object_ref_sink (_tmp82_);
	_g_object_unref0 (self->priv->toolScroll);
	self->priv->toolScroll = _tmp82_;
	_tmp83_ = self->priv->toolScroll;
	gtk_tool_button_set_label ((GtkToolButton*) _tmp83_, "Scroll");
	_tmp84_ = self->priv->toolScroll;
	_tmp85_ = self->priv->toolScrollImage;
	gtk_tool_button_set_icon_widget ((GtkToolButton*) _tmp84_, (GtkWidget*) _tmp85_);
	_tmp86_ = self->priv->toolbar;
	_tmp87_ = self->priv->toolScroll;
	gtk_toolbar_insert (_tmp86_, (GtkToolItem*) _tmp87_, -1);
	_tmp88_ = self->priv->toolScroll;
	gtk_tool_item_set_tooltip_text ((GtkToolItem*) _tmp88_, "Scroll: Move your view of the timing diagram with click and drag.");
	_tmp89_ = self->priv->toolScroll;
	g_signal_connect_object ((GtkToolButton*) _tmp89_, "clicked", (GCallback) ___lambda30__gtk_tool_button_clicked, self, 0);
	_tmp90_ = (GtkImage*) gtk_image_new_from_file (PACKAGE_DATADIR "images/toolbar/zoom.png");
	g_object_ref_sink (_tmp90_);
	_g_object_unref0 (self->priv->toolZoomImage);
	self->priv->toolZoomImage = _tmp90_;
	_tmp91_ = self->priv->toolScroll;
	_tmp92_ = (GtkRadioToolButton*) gtk_radio_tool_button_new_from_widget (_tmp91_);
	g_object_ref_sink (_tmp92_);
	_g_object_unref0 (self->priv->toolZoom);
	self->priv->toolZoom = _tmp92_;
	_tmp93_ = self->priv->toolZoom;
	gtk_tool_button_set_label ((GtkToolButton*) _tmp93_, "Zoom");
	_tmp94_ = self->priv->toolZoom;
	_tmp95_ = self->priv->toolZoomImage;
	gtk_tool_button_set_icon_widget ((GtkToolButton*) _tmp94_, (GtkWidget*) _tmp95_);
	_tmp96_ = self->priv->toolbar;
	_tmp97_ = self->priv->toolZoom;
	gtk_toolbar_insert (_tmp96_, (GtkToolItem*) _tmp97_, -1);
	_tmp98_ = self->priv->toolZoom;
	gtk_tool_item_set_tooltip_text ((GtkToolItem*) _tmp98_, "Zoom: Drag downward to stretch vertically, rightward to stretch horizo" \
"ntally.");
	_tmp99_ = self->priv->toolZoom;
	g_signal_connect_object ((GtkToolButton*) _tmp99_, "clicked", (GCallback) ___lambda31__gtk_tool_button_clicked, self, 0);
	_tmp100_ = (GtkSeparatorToolItem*) gtk_separator_tool_item_new ();
	g_object_ref_sink (_tmp100_);
	_g_object_unref0 (self->priv->toolSeparator1);
	self->priv->toolSeparator1 = _tmp100_;
	_tmp101_ = self->priv->toolbar;
	_tmp102_ = self->priv->toolSeparator1;
	gtk_toolbar_insert (_tmp101_, (GtkToolItem*) _tmp102_, -1);
	_tmp103_ = (GtkImage*) gtk_image_new_from_file (PACKAGE_DATADIR "images/toolbar/move.png");
	g_object_ref_sink (_tmp103_);
	_g_object_unref0 (self->priv->toolMoveImage);
	self->priv->toolMoveImage = _tmp103_;
	_tmp104_ = self->priv->toolScroll;
	_tmp105_ = (GtkRadioToolButton*) gtk_radio_tool_button_new_from_widget (_tmp104_);
	g_object_ref_sink (_tmp105_);
	_g_object_unref0 (self->priv->toolMove);
	self->priv->toolMove = _tmp105_;
	_tmp106_ = self->priv->toolMove;
	gtk_tool_button_set_label ((GtkToolButton*) _tmp106_, "Move");
	_tmp107_ = self->priv->toolMove;
	_tmp108_ = self->priv->toolMoveImage;
	gtk_tool_button_set_icon_widget ((GtkToolButton*) _tmp107_, (GtkWidget*) _tmp108_);
	_tmp109_ = self->priv->toolbar;
	_tmp110_ = self->priv->toolMove;
	gtk_toolbar_insert (_tmp109_, (GtkToolItem*) _tmp110_, -1);
	_tmp111_ = self->priv->toolMove;
	gtk_tool_item_set_tooltip_text ((GtkToolItem*) _tmp111_, "Move: Click and drag a trace to reorder it.");
	_tmp112_ = self->priv->toolMove;
	g_signal_connect_object ((GtkToolButton*) _tmp112_, "clicked", (GCallback) ___lambda32__gtk_tool_button_clicked, self, 0);
	_tmp113_ = (GtkImage*) gtk_image_new_from_file (PACKAGE_DATADIR "images/toolbar/delete.png");
	g_object_ref_sink (_tmp113_);
	_g_object_unref0 (self->priv->toolDeleteImage);
	self->priv->toolDeleteImage = _tmp113_;
	_tmp114_ = self->priv->toolScroll;
	_tmp115_ = (GtkRadioToolButton*) gtk_radio_tool_button_new_from_widget (_tmp114_);
	g_object_ref_sink (_tmp115_);
	_g_object_unref0 (self->priv->toolDelete);
	self->priv->toolDelete = _tmp115_;
	_tmp116_ = self->priv->toolDelete;
	gtk_tool_button_set_label ((GtkToolButton*) _tmp116_, "Delete");
	_tmp117_ = self->priv->toolDelete;
	_tmp118_ = self->priv->toolDeleteImage;
	gtk_tool_button_set_icon_widget ((GtkToolButton*) _tmp117_, (GtkWidget*) _tmp118_);
	_tmp119_ = self->priv->toolbar;
	_tmp120_ = self->priv->toolDelete;
	gtk_toolbar_insert (_tmp119_, (GtkToolItem*) _tmp120_, -1);
	_tmp121_ = self->priv->toolDelete;
	gtk_tool_item_set_tooltip_text ((GtkToolItem*) _tmp121_, "Delete: Click on a trace to delete it.");
	_tmp122_ = self->priv->toolDelete;
	g_signal_connect_object ((GtkToolButton*) _tmp122_, "clicked", (GCallback) ___lambda33__gtk_tool_button_clicked, self, 0);
	_tmp123_ = (GtkImage*) gtk_image_new_from_file (PACKAGE_DATADIR "images/toolbar/adjust.png");
	g_object_ref_sink (_tmp123_);
	_g_object_unref0 (self->priv->toolAdjustImage);
	self->priv->toolAdjustImage = _tmp123_;
	_tmp124_ = self->priv->toolScroll;
	_tmp125_ = (GtkRadioToolButton*) gtk_radio_tool_button_new_from_widget (_tmp124_);
	g_object_ref_sink (_tmp125_);
	_g_object_unref0 (self->priv->toolAdjust);
	self->priv->toolAdjust = _tmp125_;
	_tmp126_ = self->priv->toolAdjust;
	gtk_tool_button_set_label ((GtkToolButton*) _tmp126_, "Adjust");
	_tmp127_ = self->priv->toolAdjust;
	_tmp128_ = self->priv->toolAdjustImage;
	gtk_tool_button_set_icon_widget ((GtkToolButton*) _tmp127_, (GtkWidget*) _tmp128_);
	_tmp129_ = self->priv->toolbar;
	_tmp130_ = self->priv->toolAdjust;
	gtk_toolbar_insert (_tmp129_, (GtkToolItem*) _tmp130_, -1);
	_tmp131_ = self->priv->toolAdjust;
	gtk_tool_item_set_tooltip_text ((GtkToolItem*) _tmp131_, "Adjust: Click on a trace to change its properties.");
	_tmp132_ = self->priv->toolAdjust;
	g_signal_connect_object ((GtkToolButton*) _tmp132_, "clicked", (GCallback) ___lambda34__gtk_tool_button_clicked, self, 0);
	_tmp133_ = (GtkEventBox*) gtk_event_box_new ();
	g_object_ref_sink (_tmp133_);
	_g_object_unref0 (self->priv->controller);
	self->priv->controller = _tmp133_;
	_tmp134_ = self->priv->vBox;
	_tmp135_ = self->priv->controller;
	gtk_box_pack_start (_tmp134_, (GtkWidget*) _tmp135_, TRUE, TRUE, (guint) 0);
	_tmp136_ = self->priv->controller;
	g_signal_connect_object ((GtkWidget*) _tmp136_, "button-press-event", (GCallback) _timing_diagram_mouse_down_gtk_widget_button_press_event, self, 0);
	_tmp137_ = self->priv->controller;
	gtk_widget_set_events ((GtkWidget*) _tmp137_, (gint) GDK_POINTER_MOTION_MASK);
	_tmp138_ = self->priv->controller;
	g_signal_connect_object ((GtkWidget*) _tmp138_, "motion-notify-event", (GCallback) _timing_diagram_mouse_move_gtk_widget_motion_notify_event, self, 0);
	_tmp139_ = self->priv->controller;
	g_signal_connect_object ((GtkWidget*) _tmp139_, "button-release-event", (GCallback) _timing_diagram_mouse_up_gtk_widget_button_release_event, self, 0);
	_tmp140_ = (GtkDrawingArea*) gtk_drawing_area_new ();
	g_object_ref_sink (_tmp140_);
	_g_object_unref0 (self->priv->display);
	self->priv->display = _tmp140_;
	_tmp141_ = self->priv->controller;
	_tmp142_ = self->priv->display;
	gtk_container_add ((GtkContainer*) _tmp141_, (GtkWidget*) _tmp142_);
	_tmp143_ = self->priv->display;
	g_signal_connect_object ((GtkWidget*) _tmp143_, "draw", (GCallback) ___lambda35__gtk_widget_draw, self, 0);
	_tmp144_ = self->priv->display;
	g_signal_connect_object ((GtkWidget*) _tmp144_, "configure-event", (GCallback) ___lambda36__gtk_widget_configure_event, self, 0);
	gtk_widget_show_all ((GtkWidget*) self);
	gtk_widget_hide ((GtkWidget*) self);
	timing_diagram_render (self, TRUE, NULL);
}


void timing_diagram_close_diagram (TimingDiagram* self) {
	g_return_if_fail (self != NULL);
	gtk_widget_destroy ((GtkWidget*) self);
}


gboolean timing_diagram_hide_diagram (TimingDiagram* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	gtk_widget_hide ((GtkWidget*) self);
	result = TRUE;
	return result;
}


void timing_diagram_show_diagram (TimingDiagram* self) {
	GtkCheckMenuItem* _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	g_return_if_fail (self != NULL);
	gtk_widget_show_all ((GtkWidget*) self);
	gtk_window_present ((GtkWindow*) self);
	_tmp0_ = self->priv->menuViewAlwaysontop;
	_tmp1_ = gtk_check_menu_item_get_active (_tmp0_);
	_tmp2_ = _tmp1_;
	gtk_window_set_keep_above ((GtkWindow*) self, _tmp2_);
	timing_diagram_render (self, TRUE, NULL);
}


static gpointer _wire_state_ref0 (gpointer self) {
	return self ? wire_state_ref (self) : NULL;
}


static void _vala_array_add110 (WireState*** array, int* length, int* size, WireState* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (WireState*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add111 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add112 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


void timing_diagram_add_wire (TimingDiagram* self, WireState* newWireState) {
	WireState** _tmp0_;
	gint _tmp0__length1;
	PropertySet* _tmp4_;
	PropertySet* propertySet;
	PropertyItemString* _tmp5_;
	PropertyItemString* labelProperty;
	PropertySet* _tmp6_;
	PropertyItemString* _tmp7_;
	PropertySet* _tmp8_;
	PropertiesQuery* _tmp9_;
	PropertiesQuery* propertiesQuery;
	PropertiesQuery* _tmp10_;
	gint _tmp11_ = 0;
	gboolean _tmp31_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (newWireState != NULL);
	_tmp0_ = self->priv->wireStates;
	_tmp0__length1 = self->priv->wireStates_length1;
	{
		WireState** wireState_collection = NULL;
		gint wireState_collection_length1 = 0;
		gint _wireState_collection_size_ = 0;
		gint wireState_it = 0;
		wireState_collection = _tmp0_;
		wireState_collection_length1 = _tmp0__length1;
		for (wireState_it = 0; wireState_it < _tmp0__length1; wireState_it = wireState_it + 1) {
			WireState* _tmp1_;
			WireState* wireState = NULL;
			_tmp1_ = _wire_state_ref0 (wireState_collection[wireState_it]);
			wireState = _tmp1_;
			{
				WireState* _tmp2_;
				WireState* _tmp3_;
				_tmp2_ = wireState;
				_tmp3_ = newWireState;
				if (_tmp2_ == _tmp3_) {
					_wire_state_unref0 (wireState);
					return;
				}
				_wire_state_unref0 (wireState);
			}
		}
	}
	_tmp4_ = property_set_new ("Watch Wire", "Record this wire in the timing diagram.");
	propertySet = _tmp4_;
	_tmp5_ = property_item_string_new ("Label", "Display this text next to the graph.", "");
	labelProperty = _tmp5_;
	_tmp6_ = propertySet;
	_tmp7_ = labelProperty;
	property_set_add_item (_tmp6_, (PropertyItem*) _tmp7_);
	_tmp8_ = propertySet;
	_tmp9_ = properties_query_new ("Watch Wire", (GtkWindow*) self, _tmp8_);
	propertiesQuery = _tmp9_;
	gtk_window_set_keep_above ((GtkWindow*) self, FALSE);
	_tmp10_ = propertiesQuery;
	_tmp11_ = properties_query_run (_tmp10_);
	if (_tmp11_ == ((gint) GTK_RESPONSE_APPLY)) {
		PropertyItemString* _tmp12_;
		const gchar* _tmp13_;
		gchar* _tmp14_;
		gchar* label;
		WireState** _tmp15_;
		gint _tmp15__length1;
		WireState* _tmp16_;
		WireState* _tmp17_;
		const gchar* _tmp18_;
		WireState* _tmp27_;
		CompiledCircuit* _tmp28_;
		gint _tmp29_;
		gint _tmp30_;
		_tmp12_ = labelProperty;
		_tmp13_ = _tmp12_->data;
		_tmp14_ = g_strdup (_tmp13_);
		label = _tmp14_;
		_tmp15_ = self->priv->wireStates;
		_tmp15__length1 = self->priv->wireStates_length1;
		_tmp16_ = newWireState;
		_tmp17_ = _wire_state_ref0 (_tmp16_);
		_vala_array_add110 (&self->priv->wireStates, &self->priv->wireStates_length1, &self->priv->_wireStates_size_, _tmp17_);
		_tmp18_ = label;
		if (g_strcmp0 (_tmp18_, "") == 0) {
			gchar** _tmp19_;
			gint _tmp19__length1;
			WireState** _tmp20_;
			gint _tmp20__length1;
			gchar* _tmp21_ = NULL;
			gchar* _tmp22_;
			gchar* _tmp23_;
			_tmp19_ = self->priv->labels;
			_tmp19__length1 = self->priv->labels_length1;
			_tmp20_ = self->priv->wireStates;
			_tmp20__length1 = self->priv->wireStates_length1;
			_tmp21_ = g_strdup_printf ("%i", _tmp20__length1);
			_tmp22_ = _tmp21_;
			_tmp23_ = g_strconcat ("Wire ", _tmp22_, NULL);
			_vala_array_add111 (&self->priv->labels, &self->priv->labels_length1, &self->priv->_labels_size_, _tmp23_);
			_g_free0 (_tmp22_);
		} else {
			gchar** _tmp24_;
			gint _tmp24__length1;
			const gchar* _tmp25_;
			gchar* _tmp26_;
			_tmp24_ = self->priv->labels;
			_tmp24__length1 = self->priv->labels_length1;
			_tmp25_ = label;
			_tmp26_ = g_strdup (_tmp25_);
			_vala_array_add112 (&self->priv->labels, &self->priv->labels_length1, &self->priv->_labels_size_, _tmp26_);
		}
		_tmp27_ = newWireState;
		_tmp28_ = self->priv->compiledCircuit;
		_tmp29_ = _tmp28_->iterationCount;
		_tmp30_ = self->priv->iterationCountOffset;
		wire_state_start_recording (_tmp27_, _tmp29_ - _tmp30_);
		_cairo_surface_destroy0 (self->priv->diagramCache);
		self->priv->diagramCache = NULL;
		timing_diagram_render (self, TRUE, NULL);
		_g_free0 (label);
	}
	_tmp31_ = self->alwaysOnTop;
	gtk_window_set_keep_above ((GtkWindow*) self, _tmp31_);
	_properties_query_unref0 (propertiesQuery);
	_property_item_unref0 (labelProperty);
	_property_item_unref0 (propertySet);
}


static void _vala_array_add113 (WireState*** array, int* length, int* size, WireState* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (WireState*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add114 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static WireState** _vala_array_dup94 (WireState** self, int length) {
	WireState** result;
	int i;
	result = g_new0 (WireState*, length + 1);
	for (i = 0; i < length; i++) {
		WireState* _tmp0_;
		_tmp0_ = _wire_state_ref0 (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


static gchar** _vala_array_dup95 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


static void timing_diagram_forget_wire (TimingDiagram* self, gint wireNumber) {
	WireState** _tmp0_ = NULL;
	WireState** newWireStates;
	gint newWireStates_length1;
	gint _newWireStates_size_;
	gchar** _tmp1_ = NULL;
	gchar** newLabels;
	gint newLabels_length1;
	gint _newLabels_size_;
	WireState** _tmp22_;
	gint _tmp22__length1;
	WireState** _tmp23_;
	gint _tmp23__length1;
	gchar** _tmp24_;
	gint _tmp24__length1;
	gchar** _tmp25_;
	gint _tmp25__length1;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_new0 (WireState*, 0 + 1);
	newWireStates = _tmp0_;
	newWireStates_length1 = 0;
	_newWireStates_size_ = newWireStates_length1;
	_tmp1_ = g_new0 (gchar*, 0 + 1);
	newLabels = _tmp1_;
	newLabels_length1 = 0;
	_newLabels_size_ = newLabels_length1;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp2_;
			_tmp2_ = TRUE;
			while (TRUE) {
				gboolean _tmp3_;
				gint _tmp5_;
				WireState** _tmp6_;
				gint _tmp6__length1;
				gint _tmp7_;
				gint _tmp8_;
				_tmp3_ = _tmp2_;
				if (!_tmp3_) {
					gint _tmp4_;
					_tmp4_ = i;
					i = _tmp4_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp5_ = i;
				_tmp6_ = self->priv->wireStates;
				_tmp6__length1 = self->priv->wireStates_length1;
				if (!(_tmp5_ < _tmp6__length1)) {
					break;
				}
				_tmp7_ = i;
				_tmp8_ = wireNumber;
				if (_tmp7_ != _tmp8_) {
					WireState** _tmp9_;
					gint _tmp9__length1;
					WireState** _tmp10_;
					gint _tmp10__length1;
					gint _tmp11_;
					WireState* _tmp12_;
					WireState* _tmp13_;
					gchar** _tmp14_;
					gint _tmp14__length1;
					gchar** _tmp15_;
					gint _tmp15__length1;
					gint _tmp16_;
					const gchar* _tmp17_;
					gchar* _tmp18_;
					_tmp9_ = newWireStates;
					_tmp9__length1 = newWireStates_length1;
					_tmp10_ = self->priv->wireStates;
					_tmp10__length1 = self->priv->wireStates_length1;
					_tmp11_ = i;
					_tmp12_ = _tmp10_[_tmp11_];
					_tmp13_ = _wire_state_ref0 (_tmp12_);
					_vala_array_add113 (&newWireStates, &newWireStates_length1, &_newWireStates_size_, _tmp13_);
					_tmp14_ = newLabels;
					_tmp14__length1 = newLabels_length1;
					_tmp15_ = self->priv->labels;
					_tmp15__length1 = self->priv->labels_length1;
					_tmp16_ = i;
					_tmp17_ = _tmp15_[_tmp16_];
					_tmp18_ = g_strdup (_tmp17_);
					_vala_array_add114 (&newLabels, &newLabels_length1, &_newLabels_size_, _tmp18_);
				} else {
					WireState** _tmp19_;
					gint _tmp19__length1;
					gint _tmp20_;
					WireState* _tmp21_;
					_tmp19_ = self->priv->wireStates;
					_tmp19__length1 = self->priv->wireStates_length1;
					_tmp20_ = i;
					_tmp21_ = _tmp19_[_tmp20_];
					wire_state_stop_recording (_tmp21_);
				}
			}
		}
	}
	_tmp22_ = newWireStates;
	_tmp22__length1 = newWireStates_length1;
	_tmp23_ = (_tmp22_ != NULL) ? _vala_array_dup94 (_tmp22_, _tmp22__length1) : ((gpointer) _tmp22_);
	_tmp23__length1 = _tmp22__length1;
	self->priv->wireStates = (_vala_array_free (self->priv->wireStates, self->priv->wireStates_length1, (GDestroyNotify) wire_state_unref), NULL);
	self->priv->wireStates = _tmp23_;
	self->priv->wireStates_length1 = _tmp23__length1;
	self->priv->_wireStates_size_ = self->priv->wireStates_length1;
	_tmp24_ = newLabels;
	_tmp24__length1 = newLabels_length1;
	_tmp25_ = (_tmp24_ != NULL) ? _vala_array_dup95 (_tmp24_, _tmp24__length1) : ((gpointer) _tmp24_);
	_tmp25__length1 = _tmp24__length1;
	self->priv->labels = (_vala_array_free (self->priv->labels, self->priv->labels_length1, (GDestroyNotify) g_free), NULL);
	self->priv->labels = _tmp25_;
	self->priv->labels_length1 = _tmp25__length1;
	self->priv->_labels_size_ = self->priv->labels_length1;
	newLabels = (_vala_array_free (newLabels, newLabels_length1, (GDestroyNotify) g_free), NULL);
	newWireStates = (_vala_array_free (newWireStates, newWireStates_length1, (GDestroyNotify) wire_state_unref), NULL);
}


static void _vala_array_add115 (WireState*** array, int* length, int* size, WireState* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (WireState*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add116 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add117 (WireState*** array, int* length, int* size, WireState* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (WireState*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add118 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add119 (WireState*** array, int* length, int* size, WireState* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (WireState*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add120 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static WireState** _vala_array_dup96 (WireState** self, int length) {
	WireState** result;
	int i;
	result = g_new0 (WireState*, length + 1);
	for (i = 0; i < length; i++) {
		WireState* _tmp0_;
		_tmp0_ = _wire_state_ref0 (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


static gchar** _vala_array_dup97 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


static void timing_diagram_move_wire (TimingDiagram* self, gint fromNumber, gint toNumber) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gint _tmp3_;
	gboolean _tmp6_;
	gboolean _tmp8_;
	gboolean _tmp11_;
	g_return_if_fail (self != NULL);
	_tmp3_ = fromNumber;
	if (0 <= _tmp3_) {
		gint _tmp4_;
		WireState** _tmp5_;
		gint _tmp5__length1;
		_tmp4_ = fromNumber;
		_tmp5_ = self->priv->wireStates;
		_tmp5__length1 = self->priv->wireStates_length1;
		_tmp2_ = _tmp4_ < _tmp5__length1;
	} else {
		_tmp2_ = FALSE;
	}
	_tmp6_ = _tmp2_;
	if (_tmp6_) {
		gint _tmp7_;
		_tmp7_ = toNumber;
		_tmp1_ = 0 <= _tmp7_;
	} else {
		_tmp1_ = FALSE;
	}
	_tmp8_ = _tmp1_;
	if (_tmp8_) {
		gint _tmp9_;
		WireState** _tmp10_;
		gint _tmp10__length1;
		_tmp9_ = toNumber;
		_tmp10_ = self->priv->wireStates;
		_tmp10__length1 = self->priv->wireStates_length1;
		_tmp0_ = _tmp9_ < _tmp10__length1;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp11_ = _tmp0_;
	if (_tmp11_) {
		WireState** _tmp12_ = NULL;
		WireState** newWireStates;
		gint newWireStates_length1;
		gint _newWireStates_size_;
		gchar** _tmp13_ = NULL;
		gchar** newLabels;
		gint newLabels_length1;
		gint _newLabels_size_;
		WireState** _tmp14_;
		gint _tmp14__length1;
		gint _tmp15_;
		WireState* _tmp16_;
		WireState* _tmp17_;
		WireState* movingWire;
		gchar** _tmp18_;
		gint _tmp18__length1;
		gint _tmp19_;
		const gchar* _tmp20_;
		gchar* _tmp21_;
		gchar* movingLabel;
		gint insertCount;
		gint _tmp49_;
		gint _tmp50_;
		WireState** _tmp58_;
		gint _tmp58__length1;
		WireState** _tmp59_;
		gint _tmp59__length1;
		gchar** _tmp60_;
		gint _tmp60__length1;
		gchar** _tmp61_;
		gint _tmp61__length1;
		_tmp12_ = g_new0 (WireState*, 0 + 1);
		newWireStates = _tmp12_;
		newWireStates_length1 = 0;
		_newWireStates_size_ = newWireStates_length1;
		_tmp13_ = g_new0 (gchar*, 0 + 1);
		newLabels = _tmp13_;
		newLabels_length1 = 0;
		_newLabels_size_ = newLabels_length1;
		_tmp14_ = self->priv->wireStates;
		_tmp14__length1 = self->priv->wireStates_length1;
		_tmp15_ = fromNumber;
		_tmp16_ = _tmp14_[_tmp15_];
		_tmp17_ = _wire_state_ref0 (_tmp16_);
		movingWire = _tmp17_;
		_tmp18_ = self->priv->labels;
		_tmp18__length1 = self->priv->labels_length1;
		_tmp19_ = fromNumber;
		_tmp20_ = _tmp18_[_tmp19_];
		_tmp21_ = g_strdup (_tmp20_);
		movingLabel = _tmp21_;
		insertCount = 0;
		{
			gint i;
			i = 0;
			{
				gboolean _tmp22_;
				_tmp22_ = TRUE;
				while (TRUE) {
					gboolean _tmp23_;
					gint _tmp25_;
					WireState** _tmp26_;
					gint _tmp26__length1;
					gint _tmp27_;
					gint _tmp28_;
					gint _tmp36_;
					gint _tmp37_;
					_tmp23_ = _tmp22_;
					if (!_tmp23_) {
						gint _tmp24_;
						_tmp24_ = i;
						i = _tmp24_ + 1;
					}
					_tmp22_ = FALSE;
					_tmp25_ = i;
					_tmp26_ = self->priv->wireStates;
					_tmp26__length1 = self->priv->wireStates_length1;
					if (!(_tmp25_ < _tmp26__length1)) {
						break;
					}
					_tmp27_ = insertCount;
					_tmp28_ = toNumber;
					if (_tmp27_ == _tmp28_) {
						WireState** _tmp29_;
						gint _tmp29__length1;
						WireState* _tmp30_;
						WireState* _tmp31_;
						gchar** _tmp32_;
						gint _tmp32__length1;
						const gchar* _tmp33_;
						gchar* _tmp34_;
						gint _tmp35_;
						_tmp29_ = newWireStates;
						_tmp29__length1 = newWireStates_length1;
						_tmp30_ = movingWire;
						_tmp31_ = _wire_state_ref0 (_tmp30_);
						_vala_array_add115 (&newWireStates, &newWireStates_length1, &_newWireStates_size_, _tmp31_);
						_tmp32_ = newLabels;
						_tmp32__length1 = newLabels_length1;
						_tmp33_ = movingLabel;
						_tmp34_ = g_strdup (_tmp33_);
						_vala_array_add116 (&newLabels, &newLabels_length1, &_newLabels_size_, _tmp34_);
						_tmp35_ = insertCount;
						insertCount = _tmp35_ + 1;
					}
					_tmp36_ = i;
					_tmp37_ = fromNumber;
					if (_tmp36_ != _tmp37_) {
						WireState** _tmp38_;
						gint _tmp38__length1;
						WireState** _tmp39_;
						gint _tmp39__length1;
						gint _tmp40_;
						WireState* _tmp41_;
						WireState* _tmp42_;
						gchar** _tmp43_;
						gint _tmp43__length1;
						gchar** _tmp44_;
						gint _tmp44__length1;
						gint _tmp45_;
						const gchar* _tmp46_;
						gchar* _tmp47_;
						gint _tmp48_;
						_tmp38_ = newWireStates;
						_tmp38__length1 = newWireStates_length1;
						_tmp39_ = self->priv->wireStates;
						_tmp39__length1 = self->priv->wireStates_length1;
						_tmp40_ = i;
						_tmp41_ = _tmp39_[_tmp40_];
						_tmp42_ = _wire_state_ref0 (_tmp41_);
						_vala_array_add117 (&newWireStates, &newWireStates_length1, &_newWireStates_size_, _tmp42_);
						_tmp43_ = newLabels;
						_tmp43__length1 = newLabels_length1;
						_tmp44_ = self->priv->labels;
						_tmp44__length1 = self->priv->labels_length1;
						_tmp45_ = i;
						_tmp46_ = _tmp44_[_tmp45_];
						_tmp47_ = g_strdup (_tmp46_);
						_vala_array_add118 (&newLabels, &newLabels_length1, &_newLabels_size_, _tmp47_);
						_tmp48_ = insertCount;
						insertCount = _tmp48_ + 1;
					}
				}
			}
		}
		_tmp49_ = insertCount;
		_tmp50_ = toNumber;
		if (_tmp49_ == _tmp50_) {
			WireState** _tmp51_;
			gint _tmp51__length1;
			WireState* _tmp52_;
			WireState* _tmp53_;
			gchar** _tmp54_;
			gint _tmp54__length1;
			const gchar* _tmp55_;
			gchar* _tmp56_;
			gint _tmp57_;
			_tmp51_ = newWireStates;
			_tmp51__length1 = newWireStates_length1;
			_tmp52_ = movingWire;
			_tmp53_ = _wire_state_ref0 (_tmp52_);
			_vala_array_add119 (&newWireStates, &newWireStates_length1, &_newWireStates_size_, _tmp53_);
			_tmp54_ = newLabels;
			_tmp54__length1 = newLabels_length1;
			_tmp55_ = movingLabel;
			_tmp56_ = g_strdup (_tmp55_);
			_vala_array_add120 (&newLabels, &newLabels_length1, &_newLabels_size_, _tmp56_);
			_tmp57_ = insertCount;
			insertCount = _tmp57_ + 1;
		}
		_tmp58_ = newWireStates;
		_tmp58__length1 = newWireStates_length1;
		_tmp59_ = (_tmp58_ != NULL) ? _vala_array_dup96 (_tmp58_, _tmp58__length1) : ((gpointer) _tmp58_);
		_tmp59__length1 = _tmp58__length1;
		self->priv->wireStates = (_vala_array_free (self->priv->wireStates, self->priv->wireStates_length1, (GDestroyNotify) wire_state_unref), NULL);
		self->priv->wireStates = _tmp59_;
		self->priv->wireStates_length1 = _tmp59__length1;
		self->priv->_wireStates_size_ = self->priv->wireStates_length1;
		_tmp60_ = newLabels;
		_tmp60__length1 = newLabels_length1;
		_tmp61_ = (_tmp60_ != NULL) ? _vala_array_dup97 (_tmp60_, _tmp60__length1) : ((gpointer) _tmp60_);
		_tmp61__length1 = _tmp60__length1;
		self->priv->labels = (_vala_array_free (self->priv->labels, self->priv->labels_length1, (GDestroyNotify) g_free), NULL);
		self->priv->labels = _tmp61_;
		self->priv->labels_length1 = _tmp61__length1;
		self->priv->_labels_size_ = self->priv->labels_length1;
		_g_free0 (movingLabel);
		_wire_state_unref0 (movingWire);
		newLabels = (_vala_array_free (newLabels, newLabels_length1, (GDestroyNotify) g_free), NULL);
		newWireStates = (_vala_array_free (newWireStates, newWireStates_length1, (GDestroyNotify) wire_state_unref), NULL);
	}
}


static void timing_diagram_adjust_wire (TimingDiagram* self, gint wireNumber) {
	gboolean _tmp0_ = FALSE;
	gint _tmp1_;
	gboolean _tmp4_;
	g_return_if_fail (self != NULL);
	_tmp1_ = wireNumber;
	if (0 <= _tmp1_) {
		gint _tmp2_;
		WireState** _tmp3_;
		gint _tmp3__length1;
		_tmp2_ = wireNumber;
		_tmp3_ = self->priv->wireStates;
		_tmp3__length1 = self->priv->wireStates_length1;
		_tmp0_ = _tmp2_ < _tmp3__length1;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp4_ = _tmp0_;
	if (_tmp4_) {
		PropertySet* _tmp5_;
		PropertySet* propertySet;
		gchar** _tmp6_;
		gint _tmp6__length1;
		gint _tmp7_;
		const gchar* _tmp8_;
		PropertyItemString* _tmp9_;
		PropertyItemString* labelProperty;
		PropertySet* _tmp10_;
		PropertyItemString* _tmp11_;
		PropertySet* _tmp12_;
		PropertiesQuery* _tmp13_;
		PropertiesQuery* propertiesQuery;
		PropertiesQuery* _tmp14_;
		gint _tmp15_ = 0;
		gboolean _tmp32_;
		_tmp5_ = property_set_new ("Watch Wire", "Record this wire in the timing diagram.");
		propertySet = _tmp5_;
		_tmp6_ = self->priv->labels;
		_tmp6__length1 = self->priv->labels_length1;
		_tmp7_ = wireNumber;
		_tmp8_ = _tmp6_[_tmp7_];
		_tmp9_ = property_item_string_new ("Label", "Display this text next to the graph.", _tmp8_);
		labelProperty = _tmp9_;
		_tmp10_ = propertySet;
		_tmp11_ = labelProperty;
		property_set_add_item (_tmp10_, (PropertyItem*) _tmp11_);
		_tmp12_ = propertySet;
		_tmp13_ = properties_query_new ("Watch Wire", (GtkWindow*) self, _tmp12_);
		propertiesQuery = _tmp13_;
		gtk_window_set_keep_above ((GtkWindow*) self, FALSE);
		_tmp14_ = propertiesQuery;
		_tmp15_ = properties_query_run (_tmp14_);
		if (_tmp15_ == ((gint) GTK_RESPONSE_APPLY)) {
			PropertyItemString* _tmp16_;
			const gchar* _tmp17_;
			gchar* _tmp18_;
			gchar* label;
			const gchar* _tmp19_;
			_tmp16_ = labelProperty;
			_tmp17_ = _tmp16_->data;
			_tmp18_ = g_strdup (_tmp17_);
			label = _tmp18_;
			_tmp19_ = label;
			if (g_strcmp0 (_tmp19_, "") == 0) {
				gchar** _tmp20_;
				gint _tmp20__length1;
				gint _tmp21_;
				gint _tmp22_;
				gchar* _tmp23_ = NULL;
				gchar* _tmp24_;
				gchar* _tmp25_;
				gchar* _tmp26_;
				_tmp20_ = self->priv->labels;
				_tmp20__length1 = self->priv->labels_length1;
				_tmp21_ = wireNumber;
				_tmp22_ = wireNumber;
				_tmp23_ = g_strdup_printf ("%i", _tmp22_ + 1);
				_tmp24_ = _tmp23_;
				_tmp25_ = g_strconcat ("Wire ", _tmp24_, NULL);
				_g_free0 (_tmp20_[_tmp21_]);
				_tmp20_[_tmp21_] = _tmp25_;
				_tmp26_ = _tmp20_[_tmp21_];
				_g_free0 (_tmp24_);
			} else {
				gchar** _tmp27_;
				gint _tmp27__length1;
				gint _tmp28_;
				const gchar* _tmp29_;
				gchar* _tmp30_;
				gchar* _tmp31_;
				_tmp27_ = self->priv->labels;
				_tmp27__length1 = self->priv->labels_length1;
				_tmp28_ = wireNumber;
				_tmp29_ = label;
				_tmp30_ = g_strdup (_tmp29_);
				_g_free0 (_tmp27_[_tmp28_]);
				_tmp27_[_tmp28_] = _tmp30_;
				_tmp31_ = _tmp27_[_tmp28_];
			}
			_cairo_surface_destroy0 (self->priv->diagramCache);
			self->priv->diagramCache = NULL;
			timing_diagram_render (self, TRUE, NULL);
			_g_free0 (label);
		}
		_tmp32_ = self->alwaysOnTop;
		gtk_window_set_keep_above ((GtkWindow*) self, _tmp32_);
		_properties_query_unref0 (propertiesQuery);
		_property_item_unref0 (labelProperty);
		_property_item_unref0 (propertySet);
	}
}


void timing_diagram_reset_timings (TimingDiagram* self) {
	WireState** _tmp0_;
	gint _tmp0__length1;
	CompiledCircuit* _tmp3_;
	gint _tmp4_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->wireStates;
	_tmp0__length1 = self->priv->wireStates_length1;
	{
		WireState** wireState_collection = NULL;
		gint wireState_collection_length1 = 0;
		gint _wireState_collection_size_ = 0;
		gint wireState_it = 0;
		wireState_collection = _tmp0_;
		wireState_collection_length1 = _tmp0__length1;
		for (wireState_it = 0; wireState_it < _tmp0__length1; wireState_it = wireState_it + 1) {
			WireState* _tmp1_;
			WireState* wireState = NULL;
			_tmp1_ = _wire_state_ref0 (wireState_collection[wireState_it]);
			wireState = _tmp1_;
			{
				WireState* _tmp2_;
				_tmp2_ = wireState;
				wire_state_start_recording (_tmp2_, 0);
				_wire_state_unref0 (wireState);
			}
		}
	}
	self->priv->xView = 0;
	_tmp3_ = self->priv->compiledCircuit;
	_tmp4_ = _tmp3_->iterationCount;
	self->priv->iterationCountOffset = _tmp4_;
	_cairo_surface_destroy0 (self->priv->diagramCache);
	self->priv->diagramCache = NULL;
	timing_diagram_render (self, TRUE, NULL);
}


void timing_diagram_reset_view (TimingDiagram* self) {
	g_return_if_fail (self != NULL);
	self->priv->xView = 0;
	self->priv->yView = 0;
	self->priv->xZoom = (gfloat) 1;
	self->priv->yZoom = (gfloat) 25;
	_cairo_surface_destroy0 (self->priv->diagramCache);
	self->priv->diagramCache = NULL;
	timing_diagram_render (self, TRUE, NULL);
}


/**
 * Handles mouse button down in the work area. Records mouse
 * (drag) starting point.
 */
static gboolean timing_diagram_mouse_down (TimingDiagram* self, GdkEventButton* event) {
	gboolean result = FALSE;
	GdkEventButton _tmp0_;
	gdouble _tmp1_;
	GdkEventButton _tmp2_;
	gdouble _tmp3_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = *event;
	_tmp1_ = _tmp0_.x;
	self->priv->xMouseStart = (gint) _tmp1_;
	_tmp2_ = *event;
	_tmp3_ = _tmp2_.y;
	self->priv->yMouseStart = (gint) _tmp3_;
	result = FALSE;
	return result;
}


static gboolean timing_diagram_mouse_move (TimingDiagram* self, GdkEventMotion* event) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	GdkEventMotion _tmp1_;
	gdouble _tmp2_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = gtk_events_pending ();
	if (_tmp0_) {
		result = FALSE;
		return result;
	}
	_tmp1_ = *event;
	_tmp2_ = _tmp1_.x;
	self->priv->barPosition = _tmp2_;
	timing_diagram_render (self, FALSE, NULL);
	result = FALSE;
	return result;
}


/**
 * Handles mouse button up in the work area. Performs an action
 * which is determined by //mouseMode//.
 */
static gboolean timing_diagram_mouse_up (TimingDiagram* self, GdkEventButton* event) {
	gboolean result = FALSE;
	GtkAllocation areaAllocation = {0};
	GtkEventBox* _tmp0_;
	GtkAllocation _tmp1_ = {0};
	GtkAllocation _tmp2_;
	gint _tmp3_;
	gint width;
	GtkAllocation _tmp4_;
	gint _tmp5_;
	gint height;
	gint _tmp6_;
	gint xStart;
	gint _tmp7_;
	gint yStart;
	GdkEventButton _tmp8_;
	gdouble _tmp9_;
	gint xEnd;
	GdkEventButton _tmp10_;
	gdouble _tmp11_;
	gint yEnd;
	gint _tmp12_;
	gint _tmp13_;
	gint xDiff;
	gint _tmp14_;
	gint _tmp15_;
	gint yDiff;
	gint _tmp16_;
	gint _tmp17_;
	gfloat _tmp18_;
	gfloat _tmp19_ = 0.0F;
	gint wireStart;
	gint _tmp20_;
	gint _tmp21_;
	gfloat _tmp22_;
	gfloat _tmp23_ = 0.0F;
	gint wireEnd;
	gint _tmp24_ = 0;
	gint _tmp25_;
	gint _tmp28_;
	gint xDiffAbs;
	gint _tmp29_ = 0;
	gint _tmp30_;
	gint _tmp33_;
	gint yDiffAbs;
	TimingDiagramMouseMode _tmp34_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = self->priv->controller;
	gtk_widget_get_allocation ((GtkWidget*) _tmp0_, &_tmp1_);
	areaAllocation = _tmp1_;
	_tmp2_ = areaAllocation;
	_tmp3_ = _tmp2_.width;
	width = _tmp3_;
	_tmp4_ = areaAllocation;
	_tmp5_ = _tmp4_.height;
	height = _tmp5_;
	_tmp6_ = self->priv->xMouseStart;
	xStart = _tmp6_;
	_tmp7_ = self->priv->yMouseStart;
	yStart = _tmp7_ - 20;
	_tmp8_ = *event;
	_tmp9_ = _tmp8_.x;
	xEnd = (gint) _tmp9_;
	_tmp10_ = *event;
	_tmp11_ = _tmp10_.y;
	yEnd = ((gint) _tmp11_) - 20;
	_tmp12_ = xEnd;
	_tmp13_ = xStart;
	xDiff = _tmp12_ - _tmp13_;
	_tmp14_ = yEnd;
	_tmp15_ = yStart;
	yDiff = _tmp14_ - _tmp15_;
	_tmp16_ = yStart;
	_tmp17_ = self->priv->yView;
	_tmp18_ = self->priv->yZoom;
	_tmp19_ = floorf ((gfloat) (((gfloat) (_tmp16_ + _tmp17_)) / (_tmp18_ * 2.4)));
	wireStart = (gint) _tmp19_;
	_tmp20_ = yEnd;
	_tmp21_ = self->priv->yView;
	_tmp22_ = self->priv->yZoom;
	_tmp23_ = floorf ((gfloat) (((gfloat) (_tmp20_ + _tmp21_)) / (_tmp22_ * 2.4)));
	wireEnd = (gint) _tmp23_;
	_tmp25_ = xDiff;
	if (_tmp25_ > 0) {
		gint _tmp26_;
		_tmp26_ = xDiff;
		_tmp24_ = _tmp26_;
	} else {
		gint _tmp27_;
		_tmp27_ = xDiff;
		_tmp24_ = -_tmp27_;
	}
	_tmp28_ = _tmp24_;
	xDiffAbs = _tmp28_;
	_tmp30_ = yDiff;
	if (_tmp30_ > 0) {
		gint _tmp31_;
		_tmp31_ = yDiff;
		_tmp29_ = _tmp31_;
	} else {
		gint _tmp32_;
		_tmp32_ = yDiff;
		_tmp29_ = -_tmp32_;
	}
	_tmp33_ = _tmp29_;
	yDiffAbs = _tmp33_;
	_tmp34_ = self->priv->mouseMode;
	switch (_tmp34_) {
		case TIMING_DIAGRAM_MOUSE_MODE_SCROLL:
		{
			gint _tmp35_;
			gint _tmp36_;
			gfloat _tmp37_;
			gint _tmp38_;
			gint _tmp39_;
			_tmp35_ = self->priv->xView;
			_tmp36_ = xDiff;
			_tmp37_ = self->priv->xZoom;
			self->priv->xView = _tmp35_ - ((gint) (((gfloat) _tmp36_) / _tmp37_));
			_tmp38_ = self->priv->yView;
			_tmp39_ = yDiff;
			self->priv->yView = _tmp38_ - _tmp39_;
			break;
		}
		case TIMING_DIAGRAM_MOUSE_MODE_ZOOM:
		{
			gint _tmp40_;
			gint _tmp47_;
			_tmp40_ = xDiff;
			if (_tmp40_ > 0) {
				gfloat _tmp41_;
				gint _tmp42_;
				gint _tmp43_;
				_tmp41_ = self->priv->xZoom;
				_tmp42_ = xDiffAbs;
				_tmp43_ = width;
				self->priv->xZoom = _tmp41_ * (1.0f + (((gfloat) _tmp42_) / ((gfloat) _tmp43_)));
			} else {
				gfloat _tmp44_;
				gint _tmp45_;
				gint _tmp46_;
				_tmp44_ = self->priv->xZoom;
				_tmp45_ = xDiffAbs;
				_tmp46_ = width;
				self->priv->xZoom = _tmp44_ / (1.0f + (((gfloat) _tmp45_) / ((gfloat) _tmp46_)));
			}
			_tmp47_ = yDiff;
			if (_tmp47_ > 0) {
				gfloat _tmp48_;
				gint _tmp49_;
				gint _tmp50_;
				_tmp48_ = self->priv->yZoom;
				_tmp49_ = yDiffAbs;
				_tmp50_ = height;
				self->priv->yZoom = _tmp48_ * (1.0f + (((gfloat) _tmp49_) / ((gfloat) _tmp50_)));
			} else {
				gfloat _tmp51_;
				gint _tmp52_;
				gint _tmp53_;
				_tmp51_ = self->priv->yZoom;
				_tmp52_ = yDiffAbs;
				_tmp53_ = height;
				self->priv->yZoom = _tmp51_ / (1.0f + (((gfloat) _tmp52_) / ((gfloat) _tmp53_)));
			}
			break;
		}
		case TIMING_DIAGRAM_MOUSE_MODE_MOVE:
		{
			gint _tmp54_;
			gint _tmp55_;
			_tmp54_ = wireStart;
			_tmp55_ = wireEnd;
			timing_diagram_move_wire (self, _tmp54_, _tmp55_);
			break;
		}
		case TIMING_DIAGRAM_MOUSE_MODE_DELETE:
		{
			gint _tmp56_;
			_tmp56_ = wireEnd;
			timing_diagram_forget_wire (self, _tmp56_);
			break;
		}
		case TIMING_DIAGRAM_MOUSE_MODE_ADJUST:
		{
			gint _tmp57_;
			_tmp57_ = wireEnd;
			timing_diagram_adjust_wire (self, _tmp57_);
			break;
		}
		default:
		break;
	}
	_cairo_surface_destroy0 (self->priv->diagramCache);
	self->priv->diagramCache = NULL;
	timing_diagram_render (self, TRUE, NULL);
	result = FALSE;
	return result;
}


gint timing_diagram_text_length (TimingDiagram* self) {
	gint result = 0;
	gint largestLength;
	cairo_text_extents_t textExtents = {0};
	cairo_surface_t* _tmp0_;
	cairo_surface_t* imageSurface;
	cairo_surface_t* _tmp1_;
	cairo_t* _tmp2_;
	cairo_t* context;
	cairo_t* _tmp3_;
	gchar** _tmp4_;
	gint _tmp4__length1;
	g_return_val_if_fail (self != NULL, 0);
	largestLength = 0;
	_tmp0_ = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, 0, 0);
	imageSurface = _tmp0_;
	_tmp1_ = imageSurface;
	_tmp2_ = cairo_create (_tmp1_);
	context = _tmp2_;
	_tmp3_ = context;
	cairo_set_font_size (_tmp3_, (gdouble) 16);
	_tmp4_ = self->priv->labels;
	_tmp4__length1 = self->priv->labels_length1;
	{
		gchar** label_collection = NULL;
		gint label_collection_length1 = 0;
		gint _label_collection_size_ = 0;
		gint label_it = 0;
		label_collection = _tmp4_;
		label_collection_length1 = _tmp4__length1;
		for (label_it = 0; label_it < _tmp4__length1; label_it = label_it + 1) {
			gchar* _tmp5_;
			gchar* label = NULL;
			_tmp5_ = g_strdup (label_collection[label_it]);
			label = _tmp5_;
			{
				cairo_t* _tmp6_;
				const gchar* _tmp7_;
				cairo_text_extents_t _tmp8_ = {0};
				gint _tmp9_;
				cairo_text_extents_t _tmp10_;
				gdouble _tmp11_;
				_tmp6_ = context;
				_tmp7_ = label;
				cairo_text_extents (_tmp6_, _tmp7_, &_tmp8_);
				textExtents = _tmp8_;
				_tmp9_ = largestLength;
				_tmp10_ = textExtents;
				_tmp11_ = _tmp10_.width;
				if (_tmp9_ < ((gint) _tmp11_)) {
					cairo_text_extents_t _tmp12_;
					gdouble _tmp13_;
					_tmp12_ = textExtents;
					_tmp13_ = _tmp12_.width;
					largestLength = (gint) _tmp13_;
				}
				_g_free0 (label);
			}
		}
	}
	result = largestLength;
	_cairo_destroy0 (context);
	_cairo_surface_destroy0 (imageSurface);
	return result;
}


void timing_diagram_render_labels (TimingDiagram* self, cairo_t* context, gboolean fullRender, gint width, gint* largestLength) {
	gint _vala_largestLength = 0;
	cairo_matrix_t oldMatrix = {0};
	cairo_text_extents_t textExtents = {0};
	cairo_t* _tmp0_;
	cairo_matrix_t _tmp1_ = {0};
	cairo_t* _tmp2_;
	gfloat _tmp3_;
	gint _tmp4_;
	gchar** _tmp5_;
	gint _tmp5__length1;
	cairo_t* _tmp30_;
	cairo_matrix_t _tmp31_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	_vala_largestLength = 0;
	_tmp0_ = context;
	cairo_get_matrix (_tmp0_, &_tmp1_);
	oldMatrix = _tmp1_;
	_tmp2_ = context;
	_tmp3_ = self->priv->yZoom;
	_tmp4_ = self->priv->yView;
	cairo_translate (_tmp2_, (gdouble) 10, ((_tmp3_ * 1.2) - _tmp4_) + 20);
	_tmp5_ = self->priv->labels;
	_tmp5__length1 = self->priv->labels_length1;
	{
		gchar** label_collection = NULL;
		gint label_collection_length1 = 0;
		gint _label_collection_size_ = 0;
		gint label_it = 0;
		label_collection = _tmp5_;
		label_collection_length1 = _tmp5__length1;
		for (label_it = 0; label_it < _tmp5__length1; label_it = label_it + 1) {
			gchar* _tmp6_;
			gchar* label = NULL;
			_tmp6_ = g_strdup (label_collection[label_it]);
			label = _tmp6_;
			{
				cairo_t* _tmp7_;
				cairo_t* _tmp8_;
				cairo_t* _tmp9_;
				const gchar* _tmp10_;
				cairo_text_extents_t _tmp11_ = {0};
				gint _tmp12_;
				cairo_text_extents_t _tmp13_;
				gdouble _tmp14_;
				gboolean _tmp17_;
				_tmp7_ = context;
				cairo_set_source_rgb (_tmp7_, (gdouble) 0, (gdouble) 0, (gdouble) 0);
				_tmp8_ = context;
				cairo_set_font_size (_tmp8_, (gdouble) 16);
				_tmp9_ = context;
				_tmp10_ = label;
				cairo_text_extents (_tmp9_, _tmp10_, &_tmp11_);
				textExtents = _tmp11_;
				_tmp12_ = _vala_largestLength;
				_tmp13_ = textExtents;
				_tmp14_ = _tmp13_.width;
				if (_tmp12_ < ((gint) _tmp14_)) {
					cairo_text_extents_t _tmp15_;
					gdouble _tmp16_;
					_tmp15_ = textExtents;
					_tmp16_ = _tmp15_.width;
					_vala_largestLength = (gint) _tmp16_;
				}
				_tmp17_ = fullRender;
				if (_tmp17_) {
					cairo_t* _tmp18_;
					const gchar* _tmp19_;
					cairo_t* _tmp20_;
					cairo_t* _tmp21_;
					cairo_t* _tmp22_;
					gfloat _tmp23_;
					cairo_t* _tmp24_;
					gint _tmp25_;
					gfloat _tmp26_;
					cairo_t* _tmp27_;
					cairo_t* _tmp28_;
					gfloat _tmp29_;
					_tmp18_ = context;
					_tmp19_ = label;
					cairo_show_text (_tmp18_, _tmp19_);
					_tmp20_ = context;
					cairo_stroke (_tmp20_);
					_tmp21_ = context;
					cairo_set_source_rgba (_tmp21_, (gdouble) 0, (gdouble) 0, (gdouble) 0, 0.25);
					_tmp22_ = context;
					_tmp23_ = self->priv->yZoom;
					cairo_move_to (_tmp22_, (gdouble) (-10), (-_tmp23_) * 1.2);
					_tmp24_ = context;
					_tmp25_ = width;
					_tmp26_ = self->priv->yZoom;
					cairo_line_to (_tmp24_, (gdouble) _tmp25_, (-_tmp26_) * 1.2);
					_tmp27_ = context;
					cairo_stroke (_tmp27_);
					_tmp28_ = context;
					_tmp29_ = self->priv->yZoom;
					cairo_translate (_tmp28_, (gdouble) 0, _tmp29_ * 2.4);
				}
				_g_free0 (label);
			}
		}
	}
	_tmp30_ = context;
	_tmp31_ = oldMatrix;
	cairo_set_matrix (_tmp30_, &_tmp31_);
	if (largestLength) {
		*largestLength = _vala_largestLength;
	}
}


void timing_diagram_render_graphs (TimingDiagram* self, cairo_t* context, gboolean fullRender, gint width, gint largestLength) {
	cairo_matrix_t oldMatrix = {0};
	cairo_t* _tmp0_;
	cairo_matrix_t _tmp1_ = {0};
	cairo_t* _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	gfloat _tmp5_;
	gfloat _tmp6_;
	gint _tmp7_;
	gint _tmp8_;
	gint _tmp9_;
	gint _tmp10_;
	gfloat _tmp11_;
	gint xLimit;
	WireState** _tmp12_;
	gint _tmp12__length1;
	cairo_t* _tmp22_;
	cairo_matrix_t _tmp23_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	_tmp0_ = context;
	cairo_get_matrix (_tmp0_, &_tmp1_);
	oldMatrix = _tmp1_;
	_tmp2_ = context;
	_tmp3_ = largestLength;
	_tmp4_ = self->priv->xView;
	_tmp5_ = self->priv->xZoom;
	_tmp6_ = self->priv->yZoom;
	_tmp7_ = self->priv->yView;
	cairo_translate (_tmp2_, (gdouble) ((_tmp3_ + 20) - (((gfloat) _tmp4_) * _tmp5_)), ((_tmp6_ * 1.2) - _tmp7_) + 20);
	_tmp8_ = width;
	_tmp9_ = largestLength;
	_tmp10_ = self->priv->xView;
	_tmp11_ = self->priv->xZoom;
	xLimit = (gint) (((gfloat) ((_tmp8_ - (_tmp9_ + 20)) + _tmp10_)) / _tmp11_);
	_tmp12_ = self->priv->wireStates;
	_tmp12__length1 = self->priv->wireStates_length1;
	{
		WireState** wireState_collection = NULL;
		gint wireState_collection_length1 = 0;
		gint _wireState_collection_size_ = 0;
		gint wireState_it = 0;
		wireState_collection = _tmp12_;
		wireState_collection_length1 = _tmp12__length1;
		for (wireState_it = 0; wireState_it < _tmp12__length1; wireState_it = wireState_it + 1) {
			WireState* _tmp13_;
			WireState* wireState = NULL;
			_tmp13_ = _wire_state_ref0 (wireState_collection[wireState_it]);
			wireState = _tmp13_;
			{
				WireState* _tmp14_;
				cairo_t* _tmp15_;
				gint _tmp16_;
				gint _tmp17_;
				gfloat _tmp18_;
				gfloat _tmp19_;
				cairo_t* _tmp20_;
				gfloat _tmp21_;
				_tmp14_ = wireState;
				_tmp15_ = context;
				_tmp16_ = self->priv->xView;
				_tmp17_ = xLimit;
				_tmp18_ = self->priv->yZoom;
				_tmp19_ = self->priv->xZoom;
				wire_state_render_history (_tmp14_, _tmp15_, _tmp16_, _tmp17_, _tmp18_, _tmp19_);
				_tmp20_ = context;
				_tmp21_ = self->priv->yZoom;
				cairo_translate (_tmp20_, (gdouble) 0, _tmp21_ * 2.4);
				_wire_state_unref0 (wireState);
			}
		}
	}
	_tmp22_ = context;
	_tmp23_ = oldMatrix;
	cairo_set_matrix (_tmp22_, &_tmp23_);
}


void timing_diagram_render_ruler (TimingDiagram* self, cairo_t* context, gboolean fullRender, gint width, gint height, gint largestLength) {
	gfloat xLabel = 0.0F;
	gint labelValue = 0;
	cairo_t* _tmp0_;
	cairo_t* _tmp1_;
	gint _tmp2_;
	cairo_t* _tmp3_;
	cairo_t* _tmp4_;
	gint _tmp5_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	_tmp0_ = context;
	cairo_set_source_rgb (_tmp0_, (gdouble) 1, (gdouble) 1, (gdouble) 1);
	_tmp1_ = context;
	_tmp2_ = width;
	cairo_rectangle (_tmp1_, (gdouble) 0, (gdouble) 0, (gdouble) _tmp2_, (gdouble) 20);
	_tmp3_ = context;
	cairo_fill (_tmp3_);
	_tmp4_ = context;
	cairo_stroke (_tmp4_);
	_tmp5_ = self->priv->xView;
	if (_tmp5_ < 0) {
		gint _tmp6_;
		gint _tmp7_;
		gfloat _tmp8_;
		_tmp6_ = largestLength;
		_tmp7_ = self->priv->xView;
		_tmp8_ = self->priv->xZoom;
		xLabel = (_tmp6_ + 20) - (((gfloat) _tmp7_) * _tmp8_);
		labelValue = 0;
	} else {
		gint _tmp9_;
		gint _tmp10_;
		gfloat _tmp11_;
		gint _tmp12_;
		gint _tmp13_;
		_tmp9_ = largestLength;
		_tmp10_ = self->priv->xView;
		_tmp11_ = self->priv->xZoom;
		xLabel = (_tmp9_ + 20) - (((gfloat) (_tmp10_ % 50)) * _tmp11_);
		_tmp12_ = self->priv->xView;
		_tmp13_ = self->priv->xView;
		labelValue = _tmp12_ - (_tmp13_ % 50);
	}
	{
		gboolean _tmp14_;
		_tmp14_ = TRUE;
		while (TRUE) {
			gboolean _tmp15_;
			gfloat _tmp19_;
			gint _tmp20_;
			gint _tmp21_;
			_tmp15_ = _tmp14_;
			if (!_tmp15_) {
				gfloat _tmp16_;
				gfloat _tmp17_;
				gint _tmp18_;
				_tmp16_ = xLabel;
				_tmp17_ = self->priv->xZoom;
				xLabel = _tmp16_ + (5 * _tmp17_);
				_tmp18_ = labelValue;
				labelValue = _tmp18_ + 5;
			}
			_tmp14_ = FALSE;
			_tmp19_ = xLabel;
			_tmp20_ = width;
			if (!(_tmp19_ < ((gfloat) _tmp20_))) {
				break;
			}
			_tmp21_ = labelValue;
			if ((_tmp21_ % 50) == 0) {
				cairo_t* _tmp22_;
				cairo_t* _tmp23_;
				gfloat _tmp24_;
				cairo_t* _tmp25_;
				gfloat _tmp26_;
				cairo_t* _tmp27_;
				cairo_t* _tmp28_;
				gfloat _tmp29_;
				cairo_t* _tmp30_;
				gint _tmp31_;
				gchar* _tmp32_ = NULL;
				gchar* _tmp33_;
				cairo_t* _tmp34_;
				gboolean _tmp35_ = FALSE;
				gboolean _tmp36_ = FALSE;
				gboolean _tmp37_;
				gboolean _tmp39_;
				gboolean _tmp42_;
				_tmp22_ = context;
				cairo_set_source_rgba (_tmp22_, (gdouble) 0, (gdouble) 0, (gdouble) 0, (gdouble) 1);
				_tmp23_ = context;
				_tmp24_ = xLabel;
				cairo_move_to (_tmp23_, (gdouble) _tmp24_, (gdouble) 0);
				_tmp25_ = context;
				_tmp26_ = xLabel;
				cairo_line_to (_tmp25_, (gdouble) _tmp26_, (gdouble) 19);
				_tmp27_ = context;
				cairo_set_font_size (_tmp27_, (gdouble) 12);
				_tmp28_ = context;
				_tmp29_ = xLabel;
				cairo_move_to (_tmp28_, (gdouble) (_tmp29_ + 2), (gdouble) 16);
				_tmp30_ = context;
				_tmp31_ = labelValue;
				_tmp32_ = g_strdup_printf ("%i", _tmp31_);
				_tmp33_ = _tmp32_;
				cairo_show_text (_tmp30_, _tmp33_);
				_g_free0 (_tmp33_);
				_tmp34_ = context;
				cairo_stroke (_tmp34_);
				_tmp37_ = fullRender;
				if (_tmp37_) {
					gboolean _tmp38_;
					_tmp38_ = self->priv->showGrid;
					_tmp36_ = _tmp38_;
				} else {
					_tmp36_ = FALSE;
				}
				_tmp39_ = _tmp36_;
				if (_tmp39_) {
					gfloat _tmp40_;
					gint _tmp41_;
					_tmp40_ = xLabel;
					_tmp41_ = largestLength;
					_tmp35_ = _tmp40_ >= ((gfloat) (_tmp41_ + 20));
				} else {
					_tmp35_ = FALSE;
				}
				_tmp42_ = _tmp35_;
				if (_tmp42_) {
					cairo_t* _tmp43_;
					cairo_t* _tmp44_;
					gfloat _tmp45_;
					cairo_t* _tmp46_;
					gfloat _tmp47_;
					gint _tmp48_;
					cairo_t* _tmp49_;
					_tmp43_ = context;
					cairo_set_source_rgba (_tmp43_, (gdouble) 0, (gdouble) 0, (gdouble) 0, 0.25);
					_tmp44_ = context;
					_tmp45_ = xLabel;
					cairo_move_to (_tmp44_, (gdouble) _tmp45_, (gdouble) 20);
					_tmp46_ = context;
					_tmp47_ = xLabel;
					_tmp48_ = height;
					cairo_line_to (_tmp46_, (gdouble) _tmp47_, (gdouble) _tmp48_);
					_tmp49_ = context;
					cairo_stroke (_tmp49_);
				}
			} else {
				cairo_t* _tmp50_;
				cairo_t* _tmp51_;
				gfloat _tmp52_;
				cairo_t* _tmp53_;
				gfloat _tmp54_;
				cairo_t* _tmp55_;
				gboolean _tmp56_ = FALSE;
				gboolean _tmp57_ = FALSE;
				gboolean _tmp58_;
				gboolean _tmp60_;
				gboolean _tmp63_;
				_tmp50_ = context;
				cairo_set_source_rgba (_tmp50_, (gdouble) 0, (gdouble) 0, (gdouble) 0, 0.25);
				_tmp51_ = context;
				_tmp52_ = xLabel;
				cairo_move_to (_tmp51_, (gdouble) _tmp52_, (gdouble) 5);
				_tmp53_ = context;
				_tmp54_ = xLabel;
				cairo_line_to (_tmp53_, (gdouble) _tmp54_, (gdouble) 15);
				_tmp55_ = context;
				cairo_stroke (_tmp55_);
				_tmp58_ = fullRender;
				if (_tmp58_) {
					gboolean _tmp59_;
					_tmp59_ = self->priv->showGrid;
					_tmp57_ = _tmp59_;
				} else {
					_tmp57_ = FALSE;
				}
				_tmp60_ = _tmp57_;
				if (_tmp60_) {
					gfloat _tmp61_;
					gint _tmp62_;
					_tmp61_ = xLabel;
					_tmp62_ = largestLength;
					_tmp56_ = _tmp61_ >= ((gfloat) (_tmp62_ + 20));
				} else {
					_tmp56_ = FALSE;
				}
				_tmp63_ = _tmp56_;
				if (_tmp63_) {
					cairo_t* _tmp64_;
					cairo_t* _tmp65_;
					gfloat _tmp66_;
					cairo_t* _tmp67_;
					gfloat _tmp68_;
					gint _tmp69_;
					cairo_t* _tmp70_;
					_tmp64_ = context;
					cairo_set_source_rgba (_tmp64_, (gdouble) 0, (gdouble) 0, (gdouble) 0, 0.125);
					_tmp65_ = context;
					_tmp66_ = xLabel;
					cairo_move_to (_tmp65_, (gdouble) _tmp66_, (gdouble) 20);
					_tmp67_ = context;
					_tmp68_ = xLabel;
					_tmp69_ = height;
					cairo_line_to (_tmp67_, (gdouble) _tmp68_, (gdouble) _tmp69_);
					_tmp70_ = context;
					cairo_stroke (_tmp70_);
				}
			}
		}
	}
}


static void timing_diagram_render_bar (TimingDiagram* self, cairo_t* context, gint height, gint largestLength) {
	gdouble _tmp0_;
	gint _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	_tmp0_ = self->priv->barPosition;
	_tmp1_ = largestLength;
	if (_tmp0_ > ((gdouble) (_tmp1_ + 20))) {
		cairo_t* _tmp2_;
		cairo_t* _tmp3_;
		gdouble _tmp4_;
		cairo_t* _tmp5_;
		gdouble _tmp6_;
		gint _tmp7_;
		cairo_t* _tmp8_;
		_tmp2_ = context;
		cairo_set_source_rgba (_tmp2_, (gdouble) 0, (gdouble) 0, (gdouble) 0, 0.25);
		_tmp3_ = context;
		_tmp4_ = self->priv->barPosition;
		cairo_move_to (_tmp3_, _tmp4_, (gdouble) 0);
		_tmp5_ = context;
		_tmp6_ = self->priv->barPosition;
		_tmp7_ = height;
		cairo_line_to (_tmp5_, _tmp6_, (gdouble) _tmp7_);
		_tmp8_ = context;
		cairo_stroke (_tmp8_);
	}
}


static gpointer _cairo_reference0 (gpointer self) {
	return self ? cairo_reference (self) : NULL;
}


gboolean timing_diagram_render (TimingDiagram* self, gboolean fullRefresh, cairo_t* passedDisplayContext) {
	gboolean result = FALSE;
	cairo_t* displayContext = NULL;
	gboolean _tmp0_;
	gboolean _tmp1_;
	gint width = 0;
	gint height = 0;
	GtkAllocation areaAllocation = {0};
	GtkDrawingArea* _tmp2_;
	GtkAllocation _tmp3_ = {0};
	GtkAllocation _tmp4_;
	gint _tmp5_;
	GtkAllocation _tmp6_;
	gint _tmp7_;
	cairo_t* _tmp8_;
	gint largestLength = 0;
	gint _tmp14_;
	gboolean _tmp15_ = FALSE;
	gboolean _tmp16_;
	gboolean _tmp18_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = gtk_widget_get_visible ((GtkWidget*) self);
	_tmp1_ = _tmp0_;
	if (!_tmp1_) {
		result = FALSE;
		_cairo_destroy0 (displayContext);
		return result;
	}
	_tmp2_ = self->priv->display;
	gtk_widget_get_allocation ((GtkWidget*) _tmp2_, &_tmp3_);
	areaAllocation = _tmp3_;
	_tmp4_ = areaAllocation;
	_tmp5_ = _tmp4_.width;
	width = _tmp5_;
	_tmp6_ = areaAllocation;
	_tmp7_ = _tmp6_.height;
	height = _tmp7_;
	_tmp8_ = passedDisplayContext;
	if (_tmp8_ == NULL) {
		GtkDrawingArea* _tmp9_;
		GdkWindow* _tmp10_ = NULL;
		cairo_t* _tmp11_ = NULL;
		_tmp9_ = self->priv->display;
		_tmp10_ = gtk_widget_get_window ((GtkWidget*) _tmp9_);
		_tmp11_ = gdk_cairo_create (_tmp10_);
		_cairo_destroy0 (displayContext);
		displayContext = _tmp11_;
	} else {
		cairo_t* _tmp12_;
		cairo_t* _tmp13_;
		_tmp12_ = passedDisplayContext;
		_tmp13_ = _cairo_reference0 (_tmp12_);
		_cairo_destroy0 (displayContext);
		displayContext = _tmp13_;
	}
	_tmp14_ = self->priv->largestLengthCache;
	if (_tmp14_ == 0) {
		fullRefresh = TRUE;
	}
	_tmp16_ = fullRefresh;
	if (_tmp16_) {
		_tmp15_ = TRUE;
	} else {
		cairo_surface_t* _tmp17_;
		_tmp17_ = self->priv->offScreenSurface;
		_tmp15_ = _tmp17_ == NULL;
	}
	_tmp18_ = _tmp15_;
	if (_tmp18_) {
		cairo_t* _tmp19_;
		cairo_surface_t* _tmp20_ = NULL;
		cairo_t* _tmp21_;
		cairo_surface_t* _tmp22_ = NULL;
		cairo_content_t _tmp23_ = 0;
		gint _tmp24_;
		gint _tmp25_;
		cairo_surface_t* _tmp26_;
		cairo_surface_t* offScreenSurface;
		cairo_surface_t* _tmp27_;
		cairo_t* _tmp28_;
		cairo_t* context;
		cairo_t* _tmp29_;
		cairo_t* _tmp30_;
		cairo_surface_t* _tmp31_;
		cairo_t* _tmp52_;
		gint _tmp53_;
		gint _tmp54_;
		cairo_t* _tmp55_;
		gint _tmp56_;
		gint _tmp57_;
		cairo_t* _tmp58_;
		cairo_surface_t* _tmp59_;
		cairo_t* _tmp60_;
		cairo_t* _tmp61_;
		cairo_surface_t* _tmp62_;
		cairo_t* _tmp63_;
		_tmp19_ = displayContext;
		_tmp20_ = cairo_get_target (_tmp19_);
		_tmp21_ = displayContext;
		_tmp22_ = cairo_get_target (_tmp21_);
		_tmp23_ = cairo_surface_get_content (_tmp22_);
		_tmp24_ = width;
		_tmp25_ = height;
		_tmp26_ = cairo_surface_create_similar (_tmp20_, _tmp23_, _tmp24_, _tmp25_);
		offScreenSurface = _tmp26_;
		_tmp27_ = offScreenSurface;
		_tmp28_ = cairo_create (_tmp27_);
		context = _tmp28_;
		_tmp29_ = context;
		cairo_set_source_rgb (_tmp29_, (gdouble) 1, (gdouble) 1, (gdouble) 1);
		_tmp30_ = context;
		cairo_paint (_tmp30_);
		_tmp31_ = self->priv->diagramCache;
		if (_tmp31_ == NULL) {
			cairo_t* _tmp32_;
			cairo_surface_t* _tmp33_ = NULL;
			gint _tmp34_;
			gint _tmp35_;
			cairo_surface_t* _tmp36_;
			cairo_surface_t* _tmp37_;
			cairo_t* _tmp38_;
			cairo_t* cacheContext;
			cairo_t* _tmp39_;
			cairo_t* _tmp40_;
			cairo_t* _tmp41_;
			cairo_t* _tmp42_;
			cairo_t* _tmp43_;
			gint _tmp44_;
			gint _tmp45_ = 0;
			cairo_t* _tmp46_;
			gint _tmp47_;
			gint _tmp48_;
			gint _tmp49_;
			gint _tmp50_;
			_tmp32_ = context;
			_tmp33_ = cairo_get_target (_tmp32_);
			_tmp34_ = width;
			_tmp35_ = height;
			_tmp36_ = cairo_surface_create_similar (_tmp33_, CAIRO_CONTENT_COLOR_ALPHA, _tmp34_, _tmp35_);
			_cairo_surface_destroy0 (self->priv->diagramCache);
			self->priv->diagramCache = _tmp36_;
			_tmp37_ = self->priv->diagramCache;
			_tmp38_ = cairo_create (_tmp37_);
			cacheContext = _tmp38_;
			_tmp39_ = cacheContext;
			cairo_set_operator (_tmp39_, CAIRO_OPERATOR_SOURCE);
			_tmp40_ = cacheContext;
			cairo_set_source_rgba (_tmp40_, (gdouble) 0, (gdouble) 0, (gdouble) 0, (gdouble) 0);
			_tmp41_ = cacheContext;
			cairo_paint (_tmp41_);
			_tmp42_ = cacheContext;
			cairo_set_operator (_tmp42_, CAIRO_OPERATOR_OVER);
			_tmp43_ = cacheContext;
			_tmp44_ = width;
			timing_diagram_render_labels (self, _tmp43_, TRUE, _tmp44_, &_tmp45_);
			largestLength = _tmp45_;
			_tmp46_ = cacheContext;
			_tmp47_ = width;
			_tmp48_ = height;
			_tmp49_ = largestLength;
			timing_diagram_render_ruler (self, _tmp46_, TRUE, _tmp47_, _tmp48_, _tmp49_);
			_tmp50_ = largestLength;
			self->priv->largestLengthCache = _tmp50_;
			_cairo_destroy0 (cacheContext);
		} else {
			gint _tmp51_;
			_tmp51_ = self->priv->largestLengthCache;
			largestLength = _tmp51_;
		}
		_tmp52_ = context;
		_tmp53_ = width;
		_tmp54_ = largestLength;
		timing_diagram_render_graphs (self, _tmp52_, TRUE, _tmp53_, _tmp54_);
		_tmp55_ = context;
		_tmp56_ = height;
		_tmp57_ = largestLength;
		timing_diagram_render_bar (self, _tmp55_, _tmp56_, _tmp57_);
		_tmp58_ = context;
		_tmp59_ = self->priv->diagramCache;
		cairo_set_source_surface (_tmp58_, _tmp59_, (gdouble) 0, (gdouble) 0);
		_tmp60_ = context;
		cairo_paint (_tmp60_);
		_tmp61_ = displayContext;
		_tmp62_ = offScreenSurface;
		cairo_set_source_surface (_tmp61_, _tmp62_, (gdouble) 0, (gdouble) 0);
		_tmp63_ = displayContext;
		cairo_paint (_tmp63_);
		_cairo_destroy0 (context);
		_cairo_surface_destroy0 (offScreenSurface);
	} else {
		cairo_surface_t* _tmp64_;
		cairo_t* _tmp65_;
		cairo_t* context;
		cairo_t* _tmp66_;
		cairo_t* _tmp67_;
		cairo_surface_t* _tmp68_;
		cairo_t* _tmp89_;
		gint _tmp90_;
		gint _tmp91_;
		cairo_t* _tmp92_;
		gint _tmp93_;
		gint _tmp94_;
		cairo_t* _tmp95_;
		cairo_surface_t* _tmp96_;
		cairo_t* _tmp97_;
		cairo_t* _tmp98_;
		cairo_surface_t* _tmp99_;
		cairo_t* _tmp100_;
		_tmp64_ = self->priv->offScreenSurface;
		_tmp65_ = cairo_create (_tmp64_);
		context = _tmp65_;
		_tmp66_ = context;
		cairo_set_source_rgb (_tmp66_, (gdouble) 1, (gdouble) 1, (gdouble) 1);
		_tmp67_ = context;
		cairo_paint (_tmp67_);
		_tmp68_ = self->priv->diagramCache;
		if (_tmp68_ == NULL) {
			cairo_t* _tmp69_;
			cairo_surface_t* _tmp70_ = NULL;
			gint _tmp71_;
			gint _tmp72_;
			cairo_surface_t* _tmp73_;
			cairo_surface_t* _tmp74_;
			cairo_t* _tmp75_;
			cairo_t* cacheContext;
			cairo_t* _tmp76_;
			cairo_t* _tmp77_;
			cairo_t* _tmp78_;
			cairo_t* _tmp79_;
			cairo_t* _tmp80_;
			gint _tmp81_;
			gint _tmp82_ = 0;
			cairo_t* _tmp83_;
			gint _tmp84_;
			gint _tmp85_;
			gint _tmp86_;
			gint _tmp87_;
			_tmp69_ = context;
			_tmp70_ = cairo_get_target (_tmp69_);
			_tmp71_ = width;
			_tmp72_ = height;
			_tmp73_ = cairo_surface_create_similar (_tmp70_, CAIRO_CONTENT_COLOR_ALPHA, _tmp71_, _tmp72_);
			_cairo_surface_destroy0 (self->priv->diagramCache);
			self->priv->diagramCache = _tmp73_;
			_tmp74_ = self->priv->diagramCache;
			_tmp75_ = cairo_create (_tmp74_);
			cacheContext = _tmp75_;
			_tmp76_ = cacheContext;
			cairo_set_operator (_tmp76_, CAIRO_OPERATOR_SOURCE);
			_tmp77_ = cacheContext;
			cairo_set_source_rgba (_tmp77_, (gdouble) 0, (gdouble) 0, (gdouble) 0, (gdouble) 0);
			_tmp78_ = cacheContext;
			cairo_paint (_tmp78_);
			_tmp79_ = cacheContext;
			cairo_set_operator (_tmp79_, CAIRO_OPERATOR_OVER);
			_tmp80_ = cacheContext;
			_tmp81_ = width;
			timing_diagram_render_labels (self, _tmp80_, FALSE, _tmp81_, &_tmp82_);
			largestLength = _tmp82_;
			_tmp83_ = cacheContext;
			_tmp84_ = width;
			_tmp85_ = height;
			_tmp86_ = largestLength;
			timing_diagram_render_ruler (self, _tmp83_, FALSE, _tmp84_, _tmp85_, _tmp86_);
			_tmp87_ = largestLength;
			self->priv->largestLengthCache = _tmp87_;
			_cairo_destroy0 (cacheContext);
		} else {
			gint _tmp88_;
			_tmp88_ = self->priv->largestLengthCache;
			largestLength = _tmp88_;
		}
		_tmp89_ = context;
		_tmp90_ = width;
		_tmp91_ = largestLength;
		timing_diagram_render_graphs (self, _tmp89_, FALSE, _tmp90_, _tmp91_);
		_tmp92_ = context;
		_tmp93_ = height;
		_tmp94_ = largestLength;
		timing_diagram_render_bar (self, _tmp92_, _tmp93_, _tmp94_);
		_tmp95_ = context;
		_tmp96_ = self->priv->diagramCache;
		cairo_set_source_surface (_tmp95_, _tmp96_, (gdouble) 0, (gdouble) 0);
		_tmp97_ = context;
		cairo_paint (_tmp97_);
		_tmp98_ = displayContext;
		_tmp99_ = self->priv->offScreenSurface;
		cairo_set_source_surface (_tmp98_, _tmp99_, (gdouble) 0, (gdouble) 0);
		_tmp100_ = displayContext;
		cairo_paint (_tmp100_);
		_cairo_destroy0 (context);
	}
	result = FALSE;
	_cairo_destroy0 (displayContext);
	return result;
}


static void _timing_diagram_file_render_image_exporter_renderer (const gchar* filename, ImageExporterImageFormat imageFormat, gdouble resolution, gpointer self) {
	timing_diagram_file_render (self, filename, imageFormat, resolution);
}


void timing_diagram_export_png (TimingDiagram* self) {
	g_return_if_fail (self != NULL);
	image_exporter_export_png (_timing_diagram_file_render_image_exporter_renderer, self);
}


void timing_diagram_export_pdf (TimingDiagram* self) {
	g_return_if_fail (self != NULL);
	image_exporter_export_pdf (_timing_diagram_file_render_image_exporter_renderer, self);
}


void timing_diagram_export_svg (TimingDiagram* self) {
	g_return_if_fail (self != NULL);
	image_exporter_export_svg (_timing_diagram_file_render_image_exporter_renderer, self);
}


/**
 * Passed to ImageExporter as a delegate and called by an export
 * function to render to a file.
 */
static void timing_diagram_file_render (TimingDiagram* self, const gchar* filename, ImageExporterImageFormat imageFormat, gdouble resolution) {
	cairo_surface_t* surface = NULL;
	CompiledCircuit* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gint duration;
	gint width = 0;
	gint height = 0;
	gint _tmp3_;
	gint _tmp4_;
	gfloat _tmp5_;
	gint _tmp6_ = 0;
	WireState** _tmp7_;
	gint _tmp7__length1;
	gfloat _tmp8_;
	gint _tmp9_;
	gint _tmp10_;
	gdouble _tmp11_;
	gint imageWidth;
	gint _tmp12_;
	gdouble _tmp13_;
	gint imageHeight;
	gfloat _tmp14_;
	gdouble _tmp15_;
	gdouble imageXZoom;
	gfloat _tmp16_;
	gdouble _tmp17_;
	gdouble imageYZoom;
	ImageExporterImageFormat _tmp18_;
	cairo_surface_t* _tmp34_;
	cairo_t* _tmp35_;
	cairo_t* context;
	ImageExporterImageFormat _tmp36_;
	cairo_t* _tmp43_;
	gdouble _tmp44_;
	gdouble _tmp45_;
	cairo_t* _tmp46_;
	FILE* _tmp47_;
	gint _tmp48_;
	gint _tmp49_;
	gdouble _tmp50_;
	gdouble _tmp51_;
	gint largestLength = 0;
	cairo_t* _tmp52_;
	gint _tmp53_;
	gint _tmp54_ = 0;
	cairo_t* _tmp55_;
	gint _tmp56_;
	gint _tmp57_;
	cairo_t* _tmp58_;
	gint _tmp59_;
	gint _tmp60_;
	gint _tmp61_;
	ImageExporterImageFormat _tmp62_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (filename != NULL);
	_tmp0_ = self->priv->compiledCircuit;
	_tmp1_ = _tmp0_->iterationCount;
	_tmp2_ = self->priv->iterationCountOffset;
	duration = _tmp1_ - _tmp2_;
	_tmp3_ = duration;
	_tmp4_ = self->priv->xView;
	_tmp5_ = self->priv->xZoom;
	_tmp6_ = timing_diagram_text_length (self);
	width = (((gint) (((gfloat) (_tmp3_ - _tmp4_)) * _tmp5_)) + _tmp6_) + 21;
	_tmp7_ = self->priv->wireStates;
	_tmp7__length1 = self->priv->wireStates_length1;
	_tmp8_ = self->priv->yZoom;
	_tmp9_ = self->priv->yView;
	height = (((gint) (((gfloat) _tmp7__length1) * (_tmp8_ * 2.4))) - _tmp9_) + 21;
	_tmp10_ = width;
	_tmp11_ = resolution;
	imageWidth = (gint) (((gdouble) _tmp10_) * _tmp11_);
	_tmp12_ = height;
	_tmp13_ = resolution;
	imageHeight = (gint) (((gdouble) _tmp12_) * _tmp13_);
	_tmp14_ = self->priv->xZoom;
	_tmp15_ = resolution;
	imageXZoom = _tmp14_ * _tmp15_;
	_tmp16_ = self->priv->yZoom;
	_tmp17_ = resolution;
	imageYZoom = (_tmp16_ * _tmp17_) / 25;
	_tmp18_ = imageFormat;
	switch (_tmp18_) {
		case IMAGE_EXPORTER_IMAGE_FORMAT_PNG_RGB:
		{
			gint _tmp19_;
			gint _tmp20_;
			cairo_surface_t* _tmp21_;
			_tmp19_ = imageWidth;
			_tmp20_ = imageHeight;
			_tmp21_ = cairo_image_surface_create (CAIRO_FORMAT_RGB24, _tmp19_, _tmp20_);
			_cairo_surface_destroy0 (surface);
			surface = _tmp21_;
			break;
		}
		case IMAGE_EXPORTER_IMAGE_FORMAT_PNG_ARGB:
		{
			gint _tmp22_;
			gint _tmp23_;
			cairo_surface_t* _tmp24_;
			_tmp22_ = imageWidth;
			_tmp23_ = imageHeight;
			_tmp24_ = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, _tmp22_, _tmp23_);
			_cairo_surface_destroy0 (surface);
			surface = _tmp24_;
			break;
		}
		case IMAGE_EXPORTER_IMAGE_FORMAT_PDF:
		{
			const gchar* _tmp25_;
			gint _tmp26_;
			gint _tmp27_;
			cairo_surface_t* _tmp28_;
			_tmp25_ = filename;
			_tmp26_ = imageWidth;
			_tmp27_ = imageHeight;
			_tmp28_ = cairo_pdf_surface_create (_tmp25_, (gdouble) _tmp26_, (gdouble) _tmp27_);
			_cairo_surface_destroy0 (surface);
			surface = _tmp28_;
			break;
		}
		case IMAGE_EXPORTER_IMAGE_FORMAT_SVG:
		case IMAGE_EXPORTER_IMAGE_FORMAT_SVG_CLEAR:
		{
			const gchar* _tmp29_;
			gint _tmp30_;
			gint _tmp31_;
			cairo_surface_t* _tmp32_;
			_tmp29_ = filename;
			_tmp30_ = imageWidth;
			_tmp31_ = imageHeight;
			_tmp32_ = cairo_svg_surface_create (_tmp29_, (gdouble) _tmp30_, (gdouble) _tmp31_);
			_cairo_surface_destroy0 (surface);
			surface = _tmp32_;
			break;
		}
		default:
		{
			FILE* _tmp33_;
			_tmp33_ = stderr;
			fprintf (_tmp33_, "Error: Unknown Export Format!\n");
			_cairo_surface_destroy0 (surface);
			return;
		}
	}
	_tmp34_ = surface;
	_tmp35_ = cairo_create (_tmp34_);
	context = _tmp35_;
	_tmp36_ = imageFormat;
	switch (_tmp36_) {
		case IMAGE_EXPORTER_IMAGE_FORMAT_PNG_ARGB:
		case IMAGE_EXPORTER_IMAGE_FORMAT_SVG_CLEAR:
		{
			cairo_t* _tmp37_;
			cairo_t* _tmp38_;
			cairo_t* _tmp39_;
			cairo_t* _tmp40_;
			_tmp37_ = context;
			cairo_set_operator (_tmp37_, CAIRO_OPERATOR_SOURCE);
			_tmp38_ = context;
			cairo_set_source_rgba (_tmp38_, (gdouble) 0, (gdouble) 0, (gdouble) 0, (gdouble) 0);
			_tmp39_ = context;
			cairo_paint (_tmp39_);
			_tmp40_ = context;
			cairo_set_operator (_tmp40_, CAIRO_OPERATOR_OVER);
			break;
		}
		default:
		{
			cairo_t* _tmp41_;
			cairo_t* _tmp42_;
			_tmp41_ = context;
			cairo_set_source_rgb (_tmp41_, (gdouble) 1, (gdouble) 1, (gdouble) 1);
			_tmp42_ = context;
			cairo_paint (_tmp42_);
			break;
		}
	}
	_tmp43_ = context;
	_tmp44_ = imageXZoom;
	_tmp45_ = imageYZoom;
	cairo_scale (_tmp43_, _tmp44_, _tmp45_);
	_tmp46_ = context;
	cairo_set_line_width (_tmp46_, (gdouble) 1);
	_tmp47_ = stdout;
	_tmp48_ = imageWidth;
	_tmp49_ = imageHeight;
	_tmp50_ = imageXZoom;
	_tmp51_ = imageYZoom;
	fprintf (_tmp47_, "Exporting timing diagram (render size = %i x %i, scale = %f x %f)\n", _tmp48_, _tmp49_, _tmp50_, _tmp51_);
	_tmp52_ = context;
	_tmp53_ = width;
	timing_diagram_render_labels (self, _tmp52_, TRUE, _tmp53_, &_tmp54_);
	largestLength = _tmp54_;
	_tmp55_ = context;
	_tmp56_ = width;
	_tmp57_ = largestLength;
	timing_diagram_render_graphs (self, _tmp55_, TRUE, _tmp56_, _tmp57_);
	_tmp58_ = context;
	_tmp59_ = width;
	_tmp60_ = height;
	_tmp61_ = largestLength;
	timing_diagram_render_ruler (self, _tmp58_, TRUE, _tmp59_, _tmp60_, _tmp61_);
	_tmp62_ = imageFormat;
	switch (_tmp62_) {
		case IMAGE_EXPORTER_IMAGE_FORMAT_PNG_RGB:
		case IMAGE_EXPORTER_IMAGE_FORMAT_PNG_ARGB:
		{
			cairo_surface_t* _tmp63_;
			const gchar* _tmp64_;
			_tmp63_ = surface;
			_tmp64_ = filename;
			cairo_surface_write_to_png (_tmp63_, _tmp64_);
			break;
		}
		default:
		break;
	}
	_cairo_destroy0 (context);
	_cairo_surface_destroy0 (surface);
}


static void timing_diagram_class_init (TimingDiagramClass * klass) {
	timing_diagram_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (TimingDiagramPrivate));
	G_OBJECT_CLASS (klass)->finalize = timing_diagram_finalize;
}


static void timing_diagram_instance_init (TimingDiagram * self) {
	self->priv = TIMING_DIAGRAM_GET_PRIVATE (self);
	self->priv->mouseMode = TIMING_DIAGRAM_MOUSE_MODE_SCROLL;
	self->priv->showGrid = TRUE;
	self->alwaysOnTop = TRUE;
	self->priv->xView = 0;
	self->priv->yView = 0;
	self->priv->xZoom = (gfloat) 1;
	self->priv->yZoom = (gfloat) 25;
	self->priv->barPosition = (gdouble) 0;
	self->priv->iterationCountOffset = 0;
}


static void timing_diagram_finalize (GObject* obj) {
	TimingDiagram * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_TIMING_DIAGRAM, TimingDiagram);
	_g_object_unref0 (self->priv->vBox);
	_g_object_unref0 (self->priv->menubar);
	_g_object_unref0 (self->priv->menuFile);
	_g_object_unref0 (self->priv->menuFileMenu);
	_g_object_unref0 (self->priv->menuFileExport);
	_g_object_unref0 (self->priv->menuFileExportMenu);
	_g_object_unref0 (self->priv->menuFileExportPng);
	_g_object_unref0 (self->priv->menuFileExportPdf);
	_g_object_unref0 (self->priv->menuFileExportSvg);
	_g_object_unref0 (self->priv->menuFileSeparator1);
	_g_object_unref0 (self->priv->menuFileExit);
	_g_object_unref0 (self->priv->menuRecording);
	_g_object_unref0 (self->priv->menuRecordingMenu);
	_g_object_unref0 (self->priv->menuRecordingReset);
	_g_object_unref0 (self->priv->menuView);
	_g_object_unref0 (self->priv->menuViewMenu);
	_g_object_unref0 (self->priv->menuViewAlwaysontop);
	_g_object_unref0 (self->priv->menuViewSeparator1);
	_g_object_unref0 (self->priv->menuViewShowgrid);
	_g_object_unref0 (self->priv->menuViewSeparator2);
	_g_object_unref0 (self->priv->menuViewReset);
	_g_object_unref0 (self->priv->toolbar);
	_g_object_unref0 (self->priv->toolScroll);
	_g_object_unref0 (self->priv->toolScrollImage);
	_g_object_unref0 (self->priv->toolZoom);
	_g_object_unref0 (self->priv->toolZoomImage);
	_g_object_unref0 (self->priv->toolSeparator1);
	_g_object_unref0 (self->priv->toolMove);
	_g_object_unref0 (self->priv->toolMoveImage);
	_g_object_unref0 (self->priv->toolDelete);
	_g_object_unref0 (self->priv->toolDeleteImage);
	_g_object_unref0 (self->priv->toolAdjust);
	_g_object_unref0 (self->priv->toolAdjustImage);
	_g_object_unref0 (self->priv->controller);
	_g_object_unref0 (self->priv->display);
	_cairo_surface_destroy0 (self->priv->diagramCache);
	_cairo_surface_destroy0 (self->priv->offScreenSurface);
	self->priv->wireStates = (_vala_array_free (self->priv->wireStates, self->priv->wireStates_length1, (GDestroyNotify) wire_state_unref), NULL);
	self->priv->labels = (_vala_array_free (self->priv->labels, self->priv->labels_length1, (GDestroyNotify) g_free), NULL);
	_compiled_circuit_unref0 (self->priv->compiledCircuit);
	G_OBJECT_CLASS (timing_diagram_parent_class)->finalize (obj);
}


GType timing_diagram_get_type (void) {
	static volatile gsize timing_diagram_type_id__volatile = 0;
	if (g_once_init_enter (&timing_diagram_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (TimingDiagramClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) timing_diagram_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (TimingDiagram), 0, (GInstanceInitFunc) timing_diagram_instance_init, NULL };
		GType timing_diagram_type_id;
		timing_diagram_type_id = g_type_register_static (GTK_TYPE_WINDOW, "TimingDiagram", &g_define_type_info, 0);
		g_once_init_leave (&timing_diagram_type_id__volatile, timing_diagram_type_id);
	}
	return timing_diagram_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



