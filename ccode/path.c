/* path.c generated by valac 0.20.1, the Vala compiler
 * generated from path.vala, do not modify */

/* 
 * SmartSim - Digital Logic Circuit Designer and Simulator
 *   
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *   
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *   
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *   
 *   Filename: path.vala
 *   
 *   Copyright Ashley Newson 2013
 */

#include <glib.h>
#include <glib-object.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <cairo.h>
#include <gobject/gvaluecollector.h>


#define TYPE_PATH (path_get_type ())
#define PATH(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PATH, Path))
#define PATH_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PATH, PathClass))
#define IS_PATH(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PATH))
#define IS_PATH_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PATH))
#define PATH_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PATH, PathClass))

typedef struct _Path Path;
typedef struct _PathClass PathClass;
typedef struct _PathPrivate PathPrivate;

#define PATH_TYPE_LINE (path_line_get_type ())

#define TYPE_DIRECTION (direction_get_type ())
typedef struct _PathLine PathLine;
typedef struct _ParamSpecPath ParamSpecPath;

typedef enum  {
	DIRECTION_NONE,
	DIRECTION_RIGHT,
	DIRECTION_DOWN,
	DIRECTION_LEFT,
	DIRECTION_UP,
	DIRECTION_HORIZONTAL,
	DIRECTION_VERTICAL,
	DIRECTION_DIAGONAL
} Direction;

struct _PathLine {
	gint x1;
	gint y1;
	gint x2;
	gint y2;
	Direction dir;
};

struct _Path {
	GTypeInstance parent_instance;
	volatile int ref_count;
	PathPrivate * priv;
	PathLine* lines;
	gint lines_length1;
	gint last;
	gint xLast;
	gint yLast;
	gint xLineStart;
	gint yLineStart;
	Direction dirLast;
};

struct _PathClass {
	GTypeClass parent_class;
	void (*finalize) (Path *self);
};

struct _ParamSpecPath {
	GParamSpec parent_instance;
};


static gpointer path_parent_class = NULL;

gpointer path_ref (gpointer instance);
void path_unref (gpointer instance);
GParamSpec* param_spec_path (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_path (GValue* value, gpointer v_object);
void value_take_path (GValue* value, gpointer v_object);
gpointer value_get_path (const GValue* value);
GType path_get_type (void) G_GNUC_CONST;
GType path_line_get_type (void) G_GNUC_CONST;
GType direction_get_type (void) G_GNUC_CONST;
PathLine* path_line_dup (const PathLine* self);
void path_line_free (PathLine* self);
enum  {
	PATH_DUMMY_PROPERTY
};
Path* path_new (gint xStart, gint yStart);
Path* path_construct (GType object_type, gint xStart, gint yStart);
void path_merge (Path* self, Path* extraPath, gboolean prepend, gboolean reverse);
static void _vala_array_add58 (PathLine** array, int* length, int* size, const PathLine* value);
static PathLine* _vala_array_dup47 (PathLine* self, int length);
static PathLine* _vala_array_dup48 (PathLine* self, int length);
static PathLine* _vala_array_dup49 (PathLine* self, int length);
static PathLine* _vala_array_dup50 (PathLine* self, int length);
static PathLine* _vala_array_dup51 (PathLine* self, int length);
static void _vala_array_add59 (PathLine** array, int* length, int* size, const PathLine* value);
static PathLine* _vala_array_dup52 (PathLine* self, int length);
gint path_append (Path* self, gint x, gint y, gfloat diagonalThreshold);
static PathLine* _vala_array_dup53 (PathLine* self, int length);
static void _vala_array_add60 (PathLine** array, int* length, int* size, const PathLine* value);
static PathLine* _vala_array_dup54 (PathLine* self, int length);
gint path_find (Path* self, gint x, gint y);
void path_move (Path* self, gint x, gint y);
void path_render (Path* self, cairo_t* context);
static void path_finalize (Path* obj);


/**
 * Creates a new path which starts at (//xStart//, //yStart//).
 */
Path* path_construct (GType object_type, gint xStart, gint yStart) {
	Path* self = NULL;
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	self = (Path*) g_type_create_instance (object_type);
	self->last = -1;
	_tmp0_ = xStart;
	self->xLast = _tmp0_;
	_tmp1_ = yStart;
	self->yLast = _tmp1_;
	_tmp2_ = xStart;
	self->xLineStart = _tmp2_;
	_tmp3_ = yStart;
	self->yLineStart = _tmp3_;
	self->dirLast = DIRECTION_NONE;
	return self;
}


Path* path_new (gint xStart, gint yStart) {
	return path_construct (TYPE_PATH, xStart, yStart);
}


static void _vala_array_add58 (PathLine** array, int* length, int* size, const PathLine* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (PathLine, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


static PathLine* _vala_array_dup47 (PathLine* self, int length) {
	return g_memdup (self, length * sizeof (PathLine));
}


static PathLine* _vala_array_dup48 (PathLine* self, int length) {
	return g_memdup (self, length * sizeof (PathLine));
}


static PathLine* _vala_array_dup49 (PathLine* self, int length) {
	return g_memdup (self, length * sizeof (PathLine));
}


static PathLine* _vala_array_dup50 (PathLine* self, int length) {
	return g_memdup (self, length * sizeof (PathLine));
}


static PathLine* _vala_array_dup51 (PathLine* self, int length) {
	return g_memdup (self, length * sizeof (PathLine));
}


static void _vala_array_add59 (PathLine** array, int* length, int* size, const PathLine* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (PathLine, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


static PathLine* _vala_array_dup52 (PathLine* self, int length) {
	return g_memdup (self, length * sizeof (PathLine));
}


void path_merge (Path* self, Path* extraPath, gboolean prepend, gboolean reverse) {
	PathLine* newLines = NULL;
	gint newLines_length1 = 0;
	gint _newLines_size_ = 0;
	PathLine* lastLines = NULL;
	gint lastLines_length1 = 0;
	gint _lastLines_size_ = 0;
	PathLine* extraLines = NULL;
	gint extraLines_length1 = 0;
	gint _extraLines_size_ = 0;
	gboolean _tmp0_;
	gboolean _tmp38_;
	PathLine* _tmp84_;
	gint _tmp84__length1;
	PathLine* _tmp85_;
	gint _tmp85__length1;
	PathLine* _tmp86_;
	gint _tmp86__length1;
	PathLine* _tmp87_;
	gint _tmp87__length1;
	gint _tmp88_;
	PathLine _tmp89_;
	gint _tmp90_;
	PathLine* _tmp91_;
	gint _tmp91__length1;
	gint _tmp92_;
	PathLine _tmp93_;
	gint _tmp94_;
	PathLine* _tmp95_;
	gint _tmp95__length1;
	gint _tmp96_;
	PathLine _tmp97_;
	gint _tmp98_;
	PathLine* _tmp99_;
	gint _tmp99__length1;
	gint _tmp100_;
	PathLine _tmp101_;
	gint _tmp102_;
	PathLine* _tmp103_;
	gint _tmp103__length1;
	gint _tmp104_;
	PathLine _tmp105_;
	Direction _tmp106_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (extraPath != NULL);
	_tmp0_ = reverse;
	if (_tmp0_) {
		PathLine* _tmp1_ = NULL;
		_tmp1_ = g_new0 (PathLine, 0);
		extraLines = (g_free (extraLines), NULL);
		extraLines = _tmp1_;
		extraLines_length1 = 0;
		_extraLines_size_ = extraLines_length1;
		{
			Path* _tmp2_;
			PathLine* _tmp3_;
			gint _tmp3__length1;
			gint i;
			_tmp2_ = extraPath;
			_tmp3_ = _tmp2_->lines;
			_tmp3__length1 = _tmp2_->lines_length1;
			i = _tmp3__length1 - 1;
			{
				gboolean _tmp4_;
				_tmp4_ = TRUE;
				while (TRUE) {
					gboolean _tmp5_;
					gint _tmp7_;
					PathLine reversedLine = {0};
					Path* _tmp8_;
					PathLine* _tmp9_;
					gint _tmp9__length1;
					gint _tmp10_;
					PathLine _tmp11_;
					gint _tmp12_;
					Path* _tmp13_;
					PathLine* _tmp14_;
					gint _tmp14__length1;
					gint _tmp15_;
					PathLine _tmp16_;
					gint _tmp17_;
					Path* _tmp18_;
					PathLine* _tmp19_;
					gint _tmp19__length1;
					gint _tmp20_;
					PathLine _tmp21_;
					gint _tmp22_;
					Path* _tmp23_;
					PathLine* _tmp24_;
					gint _tmp24__length1;
					gint _tmp25_;
					PathLine _tmp26_;
					gint _tmp27_;
					Path* _tmp28_;
					PathLine* _tmp29_;
					gint _tmp29__length1;
					gint _tmp30_;
					PathLine _tmp31_;
					Direction _tmp32_;
					PathLine* _tmp33_;
					gint _tmp33__length1;
					PathLine _tmp34_;
					_tmp5_ = _tmp4_;
					if (!_tmp5_) {
						gint _tmp6_;
						_tmp6_ = i;
						i = _tmp6_ - 1;
					}
					_tmp4_ = FALSE;
					_tmp7_ = i;
					if (!(_tmp7_ >= 0)) {
						break;
					}
					memset (&reversedLine, 0, sizeof (PathLine));
					_tmp8_ = extraPath;
					_tmp9_ = _tmp8_->lines;
					_tmp9__length1 = _tmp8_->lines_length1;
					_tmp10_ = i;
					_tmp11_ = _tmp9_[_tmp10_];
					_tmp12_ = _tmp11_.x2;
					reversedLine.x1 = _tmp12_;
					_tmp13_ = extraPath;
					_tmp14_ = _tmp13_->lines;
					_tmp14__length1 = _tmp13_->lines_length1;
					_tmp15_ = i;
					_tmp16_ = _tmp14_[_tmp15_];
					_tmp17_ = _tmp16_.x1;
					reversedLine.x2 = _tmp17_;
					_tmp18_ = extraPath;
					_tmp19_ = _tmp18_->lines;
					_tmp19__length1 = _tmp18_->lines_length1;
					_tmp20_ = i;
					_tmp21_ = _tmp19_[_tmp20_];
					_tmp22_ = _tmp21_.y2;
					reversedLine.y1 = _tmp22_;
					_tmp23_ = extraPath;
					_tmp24_ = _tmp23_->lines;
					_tmp24__length1 = _tmp23_->lines_length1;
					_tmp25_ = i;
					_tmp26_ = _tmp24_[_tmp25_];
					_tmp27_ = _tmp26_.y1;
					reversedLine.y2 = _tmp27_;
					_tmp28_ = extraPath;
					_tmp29_ = _tmp28_->lines;
					_tmp29__length1 = _tmp28_->lines_length1;
					_tmp30_ = i;
					_tmp31_ = _tmp29_[_tmp30_];
					_tmp32_ = _tmp31_.dir;
					reversedLine.dir = _tmp32_;
					_tmp33_ = extraLines;
					_tmp33__length1 = extraLines_length1;
					_tmp34_ = reversedLine;
					_vala_array_add58 (&extraLines, &extraLines_length1, &_extraLines_size_, &_tmp34_);
				}
			}
		}
	} else {
		Path* _tmp35_;
		PathLine* _tmp36_;
		gint _tmp36__length1;
		PathLine* _tmp37_;
		gint _tmp37__length1;
		_tmp35_ = extraPath;
		_tmp36_ = _tmp35_->lines;
		_tmp36__length1 = _tmp35_->lines_length1;
		_tmp37_ = (_tmp36_ != NULL) ? _vala_array_dup47 (_tmp36_, _tmp36__length1) : ((gpointer) _tmp36_);
		_tmp37__length1 = _tmp36__length1;
		extraLines = (g_free (extraLines), NULL);
		extraLines = _tmp37_;
		extraLines_length1 = _tmp37__length1;
		_extraLines_size_ = extraLines_length1;
	}
	_tmp38_ = prepend;
	if (_tmp38_) {
		PathLine* _tmp39_;
		gint _tmp39__length1;
		PathLine* _tmp40_;
		gint _tmp40__length1;
		PathLine* _tmp41_;
		gint _tmp41__length1;
		PathLine* _tmp42_;
		gint _tmp42__length1;
		_tmp39_ = extraLines;
		_tmp39__length1 = extraLines_length1;
		_tmp40_ = (_tmp39_ != NULL) ? _vala_array_dup48 (_tmp39_, _tmp39__length1) : ((gpointer) _tmp39_);
		_tmp40__length1 = _tmp39__length1;
		newLines = (g_free (newLines), NULL);
		newLines = _tmp40_;
		newLines_length1 = _tmp40__length1;
		_newLines_size_ = newLines_length1;
		_tmp41_ = self->lines;
		_tmp41__length1 = self->lines_length1;
		_tmp42_ = (_tmp41_ != NULL) ? _vala_array_dup49 (_tmp41_, _tmp41__length1) : ((gpointer) _tmp41_);
		_tmp42__length1 = _tmp41__length1;
		lastLines = (g_free (lastLines), NULL);
		lastLines = _tmp42_;
		lastLines_length1 = _tmp42__length1;
		_lastLines_size_ = lastLines_length1;
	} else {
		PathLine* _tmp43_;
		gint _tmp43__length1;
		PathLine* _tmp44_;
		gint _tmp44__length1;
		PathLine* _tmp45_;
		gint _tmp45__length1;
		PathLine* _tmp46_;
		gint _tmp46__length1;
		_tmp43_ = self->lines;
		_tmp43__length1 = self->lines_length1;
		_tmp44_ = (_tmp43_ != NULL) ? _vala_array_dup50 (_tmp43_, _tmp43__length1) : ((gpointer) _tmp43_);
		_tmp44__length1 = _tmp43__length1;
		newLines = (g_free (newLines), NULL);
		newLines = _tmp44_;
		newLines_length1 = _tmp44__length1;
		_newLines_size_ = newLines_length1;
		_tmp45_ = extraLines;
		_tmp45__length1 = extraLines_length1;
		_tmp46_ = (_tmp45_ != NULL) ? _vala_array_dup51 (_tmp45_, _tmp45__length1) : ((gpointer) _tmp45_);
		_tmp46__length1 = _tmp45__length1;
		lastLines = (g_free (lastLines), NULL);
		lastLines = _tmp46_;
		lastLines_length1 = _tmp46__length1;
		_lastLines_size_ = lastLines_length1;
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp47_;
			_tmp47_ = TRUE;
			while (TRUE) {
				gboolean _tmp48_;
				gint _tmp50_;
				PathLine* _tmp51_;
				gint _tmp51__length1;
				gint _tmp52_;
				PathLine* _tmp80_;
				gint _tmp80__length1;
				PathLine* _tmp81_;
				gint _tmp81__length1;
				gint _tmp82_;
				PathLine _tmp83_;
				_tmp48_ = _tmp47_;
				if (!_tmp48_) {
					gint _tmp49_;
					_tmp49_ = i;
					i = _tmp49_ + 1;
				}
				_tmp47_ = FALSE;
				_tmp50_ = i;
				_tmp51_ = lastLines;
				_tmp51__length1 = lastLines_length1;
				if (!(_tmp50_ < _tmp51__length1)) {
					break;
				}
				_tmp52_ = i;
				if (_tmp52_ == 0) {
					PathLine* _tmp53_;
					gint _tmp53__length1;
					gint lastNew;
					gboolean _tmp54_ = FALSE;
					PathLine* _tmp55_;
					gint _tmp55__length1;
					gint _tmp56_;
					PathLine _tmp57_;
					Direction _tmp58_;
					PathLine* _tmp59_;
					gint _tmp59__length1;
					gint _tmp60_;
					PathLine _tmp61_;
					Direction _tmp62_;
					gboolean _tmp67_;
					_tmp53_ = newLines;
					_tmp53__length1 = newLines_length1;
					lastNew = _tmp53__length1 - 1;
					_tmp55_ = newLines;
					_tmp55__length1 = newLines_length1;
					_tmp56_ = lastNew;
					_tmp57_ = _tmp55_[_tmp56_];
					_tmp58_ = _tmp57_.dir;
					_tmp59_ = lastLines;
					_tmp59__length1 = lastLines_length1;
					_tmp60_ = i;
					_tmp61_ = _tmp59_[_tmp60_];
					_tmp62_ = _tmp61_.dir;
					if (_tmp58_ == _tmp62_) {
						PathLine* _tmp63_;
						gint _tmp63__length1;
						gint _tmp64_;
						PathLine _tmp65_;
						Direction _tmp66_;
						_tmp63_ = newLines;
						_tmp63__length1 = newLines_length1;
						_tmp64_ = lastNew;
						_tmp65_ = _tmp63_[_tmp64_];
						_tmp66_ = _tmp65_.dir;
						_tmp54_ = _tmp66_ != DIRECTION_DIAGONAL;
					} else {
						_tmp54_ = FALSE;
					}
					_tmp67_ = _tmp54_;
					if (_tmp67_) {
						PathLine* _tmp68_;
						gint _tmp68__length1;
						gint _tmp69_;
						PathLine* _tmp70_;
						gint _tmp70__length1;
						gint _tmp71_;
						PathLine _tmp72_;
						gint _tmp73_;
						PathLine* _tmp74_;
						gint _tmp74__length1;
						gint _tmp75_;
						PathLine* _tmp76_;
						gint _tmp76__length1;
						gint _tmp77_;
						PathLine _tmp78_;
						gint _tmp79_;
						_tmp68_ = newLines;
						_tmp68__length1 = newLines_length1;
						_tmp69_ = lastNew;
						_tmp70_ = lastLines;
						_tmp70__length1 = lastLines_length1;
						_tmp71_ = i;
						_tmp72_ = _tmp70_[_tmp71_];
						_tmp73_ = _tmp72_.x2;
						_tmp68_[_tmp69_].x2 = _tmp73_;
						_tmp74_ = newLines;
						_tmp74__length1 = newLines_length1;
						_tmp75_ = lastNew;
						_tmp76_ = lastLines;
						_tmp76__length1 = lastLines_length1;
						_tmp77_ = i;
						_tmp78_ = _tmp76_[_tmp77_];
						_tmp79_ = _tmp78_.y2;
						_tmp74_[_tmp75_].y2 = _tmp79_;
						continue;
					}
				}
				_tmp80_ = newLines;
				_tmp80__length1 = newLines_length1;
				_tmp81_ = lastLines;
				_tmp81__length1 = lastLines_length1;
				_tmp82_ = i;
				_tmp83_ = _tmp81_[_tmp82_];
				_vala_array_add59 (&newLines, &newLines_length1, &_newLines_size_, &_tmp83_);
			}
		}
	}
	_tmp84_ = newLines;
	_tmp84__length1 = newLines_length1;
	_tmp85_ = (_tmp84_ != NULL) ? _vala_array_dup52 (_tmp84_, _tmp84__length1) : ((gpointer) _tmp84_);
	_tmp85__length1 = _tmp84__length1;
	self->lines = (g_free (self->lines), NULL);
	self->lines = _tmp85_;
	self->lines_length1 = _tmp85__length1;
	_tmp86_ = self->lines;
	_tmp86__length1 = self->lines_length1;
	self->last = _tmp86__length1 - 1;
	_tmp87_ = self->lines;
	_tmp87__length1 = self->lines_length1;
	_tmp88_ = self->last;
	_tmp89_ = _tmp87_[_tmp88_];
	_tmp90_ = _tmp89_.x2;
	self->xLast = _tmp90_;
	_tmp91_ = self->lines;
	_tmp91__length1 = self->lines_length1;
	_tmp92_ = self->last;
	_tmp93_ = _tmp91_[_tmp92_];
	_tmp94_ = _tmp93_.y2;
	self->yLast = _tmp94_;
	_tmp95_ = self->lines;
	_tmp95__length1 = self->lines_length1;
	_tmp96_ = self->last;
	_tmp97_ = _tmp95_[_tmp96_];
	_tmp98_ = _tmp97_.x1;
	self->xLineStart = _tmp98_;
	_tmp99_ = self->lines;
	_tmp99__length1 = self->lines_length1;
	_tmp100_ = self->last;
	_tmp101_ = _tmp99_[_tmp100_];
	_tmp102_ = _tmp101_.y1;
	self->yLineStart = _tmp102_;
	_tmp103_ = self->lines;
	_tmp103__length1 = self->lines_length1;
	_tmp104_ = self->last;
	_tmp105_ = _tmp103_[_tmp104_];
	_tmp106_ = _tmp105_.dir;
	self->dirLast = _tmp106_;
	extraLines = (g_free (extraLines), NULL);
	lastLines = (g_free (lastLines), NULL);
	newLines = (g_free (newLines), NULL);
}


/**
 * Add a point to the path. Returns 1 if a paths should finallise.
 * Returns 2 if a point should be undone.
 */
static PathLine* _vala_array_dup53 (PathLine* self, int length) {
	return g_memdup (self, length * sizeof (PathLine));
}


static void _vala_array_add60 (PathLine** array, int* length, int* size, const PathLine* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (PathLine, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


static PathLine* _vala_array_dup54 (PathLine* self, int length) {
	return g_memdup (self, length * sizeof (PathLine));
}


gint path_append (Path* self, gint x, gint y, gfloat diagonalThreshold) {
	gint result = 0;
	gboolean _tmp0_ = FALSE;
	gint _tmp1_;
	gint _tmp2_;
	gboolean _tmp5_;
	gint _tmp12_;
	gint _tmp13_;
	gint xDiff;
	gint _tmp14_;
	gint _tmp15_;
	gint yDiff;
	gint _tmp16_ = 0;
	gint _tmp17_;
	gint _tmp20_;
	gint xDiffAbs;
	gint _tmp21_ = 0;
	gint _tmp22_;
	gint _tmp25_;
	gint yDiffAbs;
	PathLine* _tmp26_;
	gint _tmp26__length1;
	PathLine* _tmp27_;
	gint _tmp27__length1;
	PathLine* newLines;
	gint newLines_length1;
	gint _newLines_size_;
	PathLine line = {0};
	gboolean lineAdded;
	gboolean _tmp28_ = FALSE;
	gint _tmp29_;
	gint _tmp30_;
	gboolean _tmp33_;
	PathLine* _tmp108_;
	gint _tmp108__length1;
	gint _tmp109_;
	PathLine _tmp110_;
	gint _tmp111_;
	PathLine* _tmp112_;
	gint _tmp112__length1;
	gint _tmp113_;
	PathLine _tmp114_;
	gint _tmp115_;
	PathLine* _tmp116_;
	gint _tmp116__length1;
	gint _tmp117_;
	PathLine _tmp118_;
	gint _tmp119_;
	PathLine* _tmp120_;
	gint _tmp120__length1;
	gint _tmp121_;
	PathLine _tmp122_;
	gint _tmp123_;
	PathLine* _tmp124_;
	gint _tmp124__length1;
	PathLine* _tmp125_;
	gint _tmp125__length1;
	g_return_val_if_fail (self != NULL, 0);
	_tmp1_ = x;
	_tmp2_ = self->xLast;
	if (_tmp1_ == _tmp2_) {
		gint _tmp3_;
		gint _tmp4_;
		_tmp3_ = y;
		_tmp4_ = self->yLast;
		_tmp0_ = _tmp3_ == _tmp4_;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp5_ = _tmp0_;
	if (_tmp5_) {
		gboolean _tmp6_ = FALSE;
		gint _tmp7_;
		gint _tmp8_;
		gboolean _tmp11_;
		_tmp7_ = x;
		_tmp8_ = self->xLineStart;
		if (_tmp7_ == _tmp8_) {
			gint _tmp9_;
			gint _tmp10_;
			_tmp9_ = y;
			_tmp10_ = self->yLineStart;
			_tmp6_ = _tmp9_ == _tmp10_;
		} else {
			_tmp6_ = FALSE;
		}
		_tmp11_ = _tmp6_;
		if (_tmp11_) {
			result = 2;
			return result;
		} else {
			result = 1;
			return result;
		}
	}
	_tmp12_ = x;
	_tmp13_ = self->xLast;
	xDiff = _tmp12_ - _tmp13_;
	_tmp14_ = y;
	_tmp15_ = self->yLast;
	yDiff = _tmp14_ - _tmp15_;
	_tmp17_ = xDiff;
	if (_tmp17_ > 0) {
		gint _tmp18_;
		_tmp18_ = xDiff;
		_tmp16_ = _tmp18_;
	} else {
		gint _tmp19_;
		_tmp19_ = xDiff;
		_tmp16_ = -_tmp19_;
	}
	_tmp20_ = _tmp16_;
	xDiffAbs = _tmp20_;
	_tmp22_ = yDiff;
	if (_tmp22_ > 0) {
		gint _tmp23_;
		_tmp23_ = yDiff;
		_tmp21_ = _tmp23_;
	} else {
		gint _tmp24_;
		_tmp24_ = yDiff;
		_tmp21_ = -_tmp24_;
	}
	_tmp25_ = _tmp21_;
	yDiffAbs = _tmp25_;
	_tmp26_ = self->lines;
	_tmp26__length1 = self->lines_length1;
	_tmp27_ = (_tmp26_ != NULL) ? _vala_array_dup53 (_tmp26_, _tmp26__length1) : ((gpointer) _tmp26_);
	_tmp27__length1 = _tmp26__length1;
	newLines = _tmp27_;
	newLines_length1 = _tmp27__length1;
	_newLines_size_ = newLines_length1;
	memset (&line, 0, sizeof (PathLine));
	lineAdded = FALSE;
	_tmp29_ = x;
	_tmp30_ = self->xLineStart;
	if (_tmp29_ == _tmp30_) {
		gint _tmp31_;
		gint _tmp32_;
		_tmp31_ = y;
		_tmp32_ = self->yLineStart;
		_tmp28_ = _tmp31_ == _tmp32_;
	} else {
		_tmp28_ = FALSE;
	}
	_tmp33_ = _tmp28_;
	if (_tmp33_) {
		gint _tmp34_;
		gint _tmp35_;
		gint _tmp36_;
		_tmp34_ = self->last;
		self->last = _tmp34_ - 1;
		_tmp35_ = newLines_length1;
		newLines_length1 = _tmp35_ - 1;
		_tmp36_ = self->last;
		if (_tmp36_ == (-1)) {
			result = 2;
			newLines = (g_free (newLines), NULL);
			return result;
		} else {
			PathLine* _tmp37_;
			gint _tmp37__length1;
			gint _tmp38_;
			PathLine _tmp39_;
			Direction _tmp40_;
			_tmp37_ = newLines;
			_tmp37__length1 = newLines_length1;
			_tmp38_ = self->last;
			_tmp39_ = _tmp37_[_tmp38_];
			_tmp40_ = _tmp39_.dir;
			self->dirLast = _tmp40_;
		}
	} else {
		gint _tmp41_;
		gint _tmp42_;
		gboolean _tmp103_;
		_tmp41_ = xDiffAbs;
		_tmp42_ = yDiffAbs;
		if (_tmp41_ > _tmp42_) {
			gboolean _tmp43_ = FALSE;
			gint _tmp44_;
			gfloat _tmp45_;
			gint _tmp46_;
			gboolean _tmp49_;
			_tmp44_ = yDiffAbs;
			_tmp45_ = diagonalThreshold;
			_tmp46_ = xDiffAbs;
			if (((gfloat) _tmp44_) < (_tmp45_ * ((gfloat) _tmp46_))) {
				_tmp43_ = TRUE;
			} else {
				gint _tmp47_;
				gint _tmp48_;
				_tmp47_ = y;
				_tmp48_ = self->yLast;
				_tmp43_ = _tmp47_ == _tmp48_;
			}
			_tmp49_ = _tmp43_;
			if (_tmp49_) {
				Direction _tmp50_;
				_tmp50_ = self->dirLast;
				switch (_tmp50_) {
					case DIRECTION_NONE:
					{
						gint _tmp51_;
						gint _tmp52_;
						gint _tmp53_;
						gint _tmp54_;
						self->dirLast = DIRECTION_HORIZONTAL;
						_tmp51_ = self->xLast;
						line.x1 = _tmp51_;
						_tmp52_ = self->yLast;
						line.y1 = _tmp52_;
						_tmp53_ = x;
						line.x2 = _tmp53_;
						_tmp54_ = self->yLast;
						line.y2 = _tmp54_;
						lineAdded = TRUE;
						break;
					}
					case DIRECTION_HORIZONTAL:
					{
						PathLine* _tmp55_;
						gint _tmp55__length1;
						gint _tmp56_;
						gint _tmp57_;
						self->dirLast = DIRECTION_HORIZONTAL;
						_tmp55_ = newLines;
						_tmp55__length1 = newLines_length1;
						_tmp56_ = self->last;
						_tmp57_ = x;
						_tmp55_[_tmp56_].x2 = _tmp57_;
						break;
					}
					case DIRECTION_VERTICAL:
					{
						PathLine* _tmp58_;
						gint _tmp58__length1;
						gint _tmp59_;
						gint _tmp60_;
						gint _tmp61_;
						gint _tmp62_;
						gint _tmp63_;
						gint _tmp64_;
						_tmp58_ = newLines;
						_tmp58__length1 = newLines_length1;
						_tmp59_ = self->last;
						_tmp60_ = y;
						_tmp58_[_tmp59_].y2 = _tmp60_;
						self->dirLast = DIRECTION_HORIZONTAL;
						_tmp61_ = self->xLast;
						line.x1 = _tmp61_;
						_tmp62_ = y;
						line.y1 = _tmp62_;
						_tmp63_ = x;
						line.x2 = _tmp63_;
						_tmp64_ = y;
						line.y2 = _tmp64_;
						lineAdded = TRUE;
						break;
					}
					case DIRECTION_DIAGONAL:
					{
						gint _tmp65_;
						gint _tmp66_;
						gint _tmp67_;
						gint _tmp68_;
						self->dirLast = DIRECTION_HORIZONTAL;
						_tmp65_ = self->xLast;
						line.x1 = _tmp65_;
						_tmp66_ = self->yLast;
						line.y1 = _tmp66_;
						_tmp67_ = x;
						line.x2 = _tmp67_;
						_tmp68_ = self->yLast;
						line.y2 = _tmp68_;
						lineAdded = TRUE;
						break;
					}
					default:
					break;
				}
			} else {
				gint _tmp69_;
				gint _tmp70_;
				gint _tmp71_;
				gint _tmp72_;
				self->dirLast = DIRECTION_DIAGONAL;
				_tmp69_ = self->xLast;
				line.x1 = _tmp69_;
				_tmp70_ = self->yLast;
				line.y1 = _tmp70_;
				_tmp71_ = x;
				line.x2 = _tmp71_;
				_tmp72_ = y;
				line.y2 = _tmp72_;
				lineAdded = TRUE;
			}
		} else {
			gboolean _tmp73_ = FALSE;
			gint _tmp74_;
			gfloat _tmp75_;
			gint _tmp76_;
			gboolean _tmp79_;
			_tmp74_ = xDiffAbs;
			_tmp75_ = diagonalThreshold;
			_tmp76_ = yDiffAbs;
			if (((gfloat) _tmp74_) < (_tmp75_ * ((gfloat) _tmp76_))) {
				_tmp73_ = TRUE;
			} else {
				gint _tmp77_;
				gint _tmp78_;
				_tmp77_ = x;
				_tmp78_ = self->xLast;
				_tmp73_ = _tmp77_ == _tmp78_;
			}
			_tmp79_ = _tmp73_;
			if (_tmp79_) {
				Direction _tmp80_;
				_tmp80_ = self->dirLast;
				switch (_tmp80_) {
					case DIRECTION_NONE:
					{
						gint _tmp81_;
						gint _tmp82_;
						gint _tmp83_;
						gint _tmp84_;
						self->dirLast = DIRECTION_VERTICAL;
						_tmp81_ = self->xLast;
						line.x1 = _tmp81_;
						_tmp82_ = self->yLast;
						line.y1 = _tmp82_;
						_tmp83_ = self->xLast;
						line.x2 = _tmp83_;
						_tmp84_ = y;
						line.y2 = _tmp84_;
						lineAdded = TRUE;
						break;
					}
					case DIRECTION_VERTICAL:
					{
						PathLine* _tmp85_;
						gint _tmp85__length1;
						gint _tmp86_;
						gint _tmp87_;
						self->dirLast = DIRECTION_VERTICAL;
						_tmp85_ = newLines;
						_tmp85__length1 = newLines_length1;
						_tmp86_ = self->last;
						_tmp87_ = y;
						_tmp85_[_tmp86_].y2 = _tmp87_;
						break;
					}
					case DIRECTION_HORIZONTAL:
					{
						PathLine* _tmp88_;
						gint _tmp88__length1;
						gint _tmp89_;
						gint _tmp90_;
						gint _tmp91_;
						gint _tmp92_;
						gint _tmp93_;
						gint _tmp94_;
						_tmp88_ = newLines;
						_tmp88__length1 = newLines_length1;
						_tmp89_ = self->last;
						_tmp90_ = x;
						_tmp88_[_tmp89_].x2 = _tmp90_;
						self->dirLast = DIRECTION_VERTICAL;
						_tmp91_ = x;
						line.x1 = _tmp91_;
						_tmp92_ = self->yLast;
						line.y1 = _tmp92_;
						_tmp93_ = x;
						line.x2 = _tmp93_;
						_tmp94_ = y;
						line.y2 = _tmp94_;
						lineAdded = TRUE;
						break;
					}
					case DIRECTION_DIAGONAL:
					{
						gint _tmp95_;
						gint _tmp96_;
						gint _tmp97_;
						gint _tmp98_;
						self->dirLast = DIRECTION_VERTICAL;
						_tmp95_ = self->xLast;
						line.x1 = _tmp95_;
						_tmp96_ = self->yLast;
						line.y1 = _tmp96_;
						_tmp97_ = self->xLast;
						line.x2 = _tmp97_;
						_tmp98_ = y;
						line.y2 = _tmp98_;
						lineAdded = TRUE;
						break;
					}
					default:
					break;
				}
			} else {
				gint _tmp99_;
				gint _tmp100_;
				gint _tmp101_;
				gint _tmp102_;
				self->dirLast = DIRECTION_DIAGONAL;
				_tmp99_ = self->xLast;
				line.x1 = _tmp99_;
				_tmp100_ = self->yLast;
				line.y1 = _tmp100_;
				_tmp101_ = x;
				line.x2 = _tmp101_;
				_tmp102_ = y;
				line.y2 = _tmp102_;
				lineAdded = TRUE;
			}
		}
		_tmp103_ = lineAdded;
		if (_tmp103_) {
			gint _tmp104_;
			Direction _tmp105_;
			PathLine* _tmp106_;
			gint _tmp106__length1;
			PathLine _tmp107_;
			_tmp104_ = self->last;
			self->last = _tmp104_ + 1;
			_tmp105_ = self->dirLast;
			line.dir = _tmp105_;
			_tmp106_ = newLines;
			_tmp106__length1 = newLines_length1;
			_tmp107_ = line;
			_vala_array_add60 (&newLines, &newLines_length1, &_newLines_size_, &_tmp107_);
		}
	}
	_tmp108_ = newLines;
	_tmp108__length1 = newLines_length1;
	_tmp109_ = self->last;
	_tmp110_ = _tmp108_[_tmp109_];
	_tmp111_ = _tmp110_.x1;
	self->xLineStart = _tmp111_;
	_tmp112_ = newLines;
	_tmp112__length1 = newLines_length1;
	_tmp113_ = self->last;
	_tmp114_ = _tmp112_[_tmp113_];
	_tmp115_ = _tmp114_.y1;
	self->yLineStart = _tmp115_;
	_tmp116_ = newLines;
	_tmp116__length1 = newLines_length1;
	_tmp117_ = self->last;
	_tmp118_ = _tmp116_[_tmp117_];
	_tmp119_ = _tmp118_.x2;
	self->xLast = _tmp119_;
	_tmp120_ = newLines;
	_tmp120__length1 = newLines_length1;
	_tmp121_ = self->last;
	_tmp122_ = _tmp120_[_tmp121_];
	_tmp123_ = _tmp122_.y2;
	self->yLast = _tmp123_;
	_tmp124_ = newLines;
	_tmp124__length1 = newLines_length1;
	_tmp125_ = (_tmp124_ != NULL) ? _vala_array_dup54 (_tmp124_, _tmp124__length1) : ((gpointer) _tmp124_);
	_tmp125__length1 = _tmp124__length1;
	self->lines = (g_free (self->lines), NULL);
	self->lines = _tmp125_;
	self->lines_length1 = _tmp125__length1;
	result = 0;
	newLines = (g_free (newLines), NULL);
	return result;
}


/**
 * Return 1 if the point (//x//, //y//) is on a line between points.
 * Return 2 if the point (//x//, //y//) is on a point.
 * Else return 0.
 */
gint path_find (Path* self, gint x, gint y) {
	gint result = 0;
	gint _tmp0_;
	PathLine* _tmp25_;
	gint _tmp25__length1;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->last;
	if (_tmp0_ >= 0) {
		gboolean _tmp1_ = FALSE;
		gboolean _tmp2_ = FALSE;
		gint _tmp3_;
		PathLine* _tmp4_;
		gint _tmp4__length1;
		PathLine _tmp5_;
		gint _tmp6_;
		gboolean _tmp11_;
		gboolean _tmp24_;
		_tmp3_ = x;
		_tmp4_ = self->lines;
		_tmp4__length1 = self->lines_length1;
		_tmp5_ = _tmp4_[0];
		_tmp6_ = _tmp5_.x1;
		if (_tmp3_ == _tmp6_) {
			gint _tmp7_;
			PathLine* _tmp8_;
			gint _tmp8__length1;
			PathLine _tmp9_;
			gint _tmp10_;
			_tmp7_ = y;
			_tmp8_ = self->lines;
			_tmp8__length1 = self->lines_length1;
			_tmp9_ = _tmp8_[0];
			_tmp10_ = _tmp9_.y1;
			_tmp2_ = _tmp7_ == _tmp10_;
		} else {
			_tmp2_ = FALSE;
		}
		_tmp11_ = _tmp2_;
		if (_tmp11_) {
			_tmp1_ = TRUE;
		} else {
			gboolean _tmp12_ = FALSE;
			gint _tmp13_;
			PathLine* _tmp14_;
			gint _tmp14__length1;
			gint _tmp15_;
			PathLine _tmp16_;
			gint _tmp17_;
			gboolean _tmp23_;
			_tmp13_ = x;
			_tmp14_ = self->lines;
			_tmp14__length1 = self->lines_length1;
			_tmp15_ = self->last;
			_tmp16_ = _tmp14_[_tmp15_];
			_tmp17_ = _tmp16_.x2;
			if (_tmp13_ == _tmp17_) {
				gint _tmp18_;
				PathLine* _tmp19_;
				gint _tmp19__length1;
				gint _tmp20_;
				PathLine _tmp21_;
				gint _tmp22_;
				_tmp18_ = y;
				_tmp19_ = self->lines;
				_tmp19__length1 = self->lines_length1;
				_tmp20_ = self->last;
				_tmp21_ = _tmp19_[_tmp20_];
				_tmp22_ = _tmp21_.y2;
				_tmp12_ = _tmp18_ == _tmp22_;
			} else {
				_tmp12_ = FALSE;
			}
			_tmp23_ = _tmp12_;
			_tmp1_ = _tmp23_;
		}
		_tmp24_ = _tmp1_;
		if (_tmp24_) {
			result = 2;
			return result;
		}
	}
	_tmp25_ = self->lines;
	_tmp25__length1 = self->lines_length1;
	{
		PathLine* line_collection = NULL;
		gint line_collection_length1 = 0;
		gint _line_collection_size_ = 0;
		gint line_it = 0;
		line_collection = _tmp25_;
		line_collection_length1 = _tmp25__length1;
		for (line_it = 0; line_it < _tmp25__length1; line_it = line_it + 1) {
			PathLine line = {0};
			line = line_collection[line_it];
			{
				PathLine _tmp26_;
				Direction _tmp27_;
				_tmp26_ = line;
				_tmp27_ = _tmp26_.dir;
				switch (_tmp27_) {
					case DIRECTION_HORIZONTAL:
					{
						gint _tmp28_;
						PathLine _tmp29_;
						gint _tmp30_;
						_tmp28_ = y;
						_tmp29_ = line;
						_tmp30_ = _tmp29_.y1;
						if (_tmp28_ == _tmp30_) {
							gboolean _tmp31_ = FALSE;
							gboolean _tmp32_ = FALSE;
							PathLine _tmp33_;
							gint _tmp34_;
							gint _tmp35_;
							gboolean _tmp39_;
							gboolean _tmp48_;
							_tmp33_ = line;
							_tmp34_ = _tmp33_.x1;
							_tmp35_ = x;
							if (_tmp34_ <= _tmp35_) {
								gint _tmp36_;
								PathLine _tmp37_;
								gint _tmp38_;
								_tmp36_ = x;
								_tmp37_ = line;
								_tmp38_ = _tmp37_.x2;
								_tmp32_ = _tmp36_ <= _tmp38_;
							} else {
								_tmp32_ = FALSE;
							}
							_tmp39_ = _tmp32_;
							if (_tmp39_) {
								_tmp31_ = TRUE;
							} else {
								gboolean _tmp40_ = FALSE;
								PathLine _tmp41_;
								gint _tmp42_;
								gint _tmp43_;
								gboolean _tmp47_;
								_tmp41_ = line;
								_tmp42_ = _tmp41_.x1;
								_tmp43_ = x;
								if (_tmp42_ >= _tmp43_) {
									gint _tmp44_;
									PathLine _tmp45_;
									gint _tmp46_;
									_tmp44_ = x;
									_tmp45_ = line;
									_tmp46_ = _tmp45_.x2;
									_tmp40_ = _tmp44_ >= _tmp46_;
								} else {
									_tmp40_ = FALSE;
								}
								_tmp47_ = _tmp40_;
								_tmp31_ = _tmp47_;
							}
							_tmp48_ = _tmp31_;
							if (_tmp48_) {
								result = 1;
								return result;
							}
						}
						break;
					}
					case DIRECTION_VERTICAL:
					{
						gint _tmp49_;
						PathLine _tmp50_;
						gint _tmp51_;
						_tmp49_ = x;
						_tmp50_ = line;
						_tmp51_ = _tmp50_.x1;
						if (_tmp49_ == _tmp51_) {
							gboolean _tmp52_ = FALSE;
							gboolean _tmp53_ = FALSE;
							PathLine _tmp54_;
							gint _tmp55_;
							gint _tmp56_;
							gboolean _tmp60_;
							gboolean _tmp69_;
							_tmp54_ = line;
							_tmp55_ = _tmp54_.y1;
							_tmp56_ = y;
							if (_tmp55_ <= _tmp56_) {
								gint _tmp57_;
								PathLine _tmp58_;
								gint _tmp59_;
								_tmp57_ = y;
								_tmp58_ = line;
								_tmp59_ = _tmp58_.y2;
								_tmp53_ = _tmp57_ <= _tmp59_;
							} else {
								_tmp53_ = FALSE;
							}
							_tmp60_ = _tmp53_;
							if (_tmp60_) {
								_tmp52_ = TRUE;
							} else {
								gboolean _tmp61_ = FALSE;
								PathLine _tmp62_;
								gint _tmp63_;
								gint _tmp64_;
								gboolean _tmp68_;
								_tmp62_ = line;
								_tmp63_ = _tmp62_.y1;
								_tmp64_ = y;
								if (_tmp63_ >= _tmp64_) {
									gint _tmp65_;
									PathLine _tmp66_;
									gint _tmp67_;
									_tmp65_ = y;
									_tmp66_ = line;
									_tmp67_ = _tmp66_.y2;
									_tmp61_ = _tmp65_ >= _tmp67_;
								} else {
									_tmp61_ = FALSE;
								}
								_tmp68_ = _tmp61_;
								_tmp52_ = _tmp68_;
							}
							_tmp69_ = _tmp52_;
							if (_tmp69_) {
								result = 1;
								return result;
							}
						}
						break;
					}
					case DIRECTION_DIAGONAL:
					{
						gint xMin = 0;
						gint xMax = 0;
						gint yMin = 0;
						gint yMax = 0;
						gboolean _tmp70_ = FALSE;
						gboolean _tmp71_ = FALSE;
						gint _tmp72_;
						PathLine _tmp73_;
						gint _tmp74_;
						gboolean _tmp78_;
						gboolean _tmp87_;
						PathLine _tmp88_;
						gint _tmp89_;
						PathLine _tmp90_;
						gint _tmp91_;
						PathLine _tmp100_;
						gint _tmp101_;
						PathLine _tmp102_;
						gint _tmp103_;
						gboolean _tmp112_ = FALSE;
						gboolean _tmp113_ = FALSE;
						gboolean _tmp114_ = FALSE;
						gint _tmp115_;
						gint _tmp116_;
						gboolean _tmp119_;
						gboolean _tmp122_;
						gboolean _tmp125_;
						_tmp72_ = x;
						_tmp73_ = line;
						_tmp74_ = _tmp73_.x1;
						if (_tmp72_ == _tmp74_) {
							gint _tmp75_;
							PathLine _tmp76_;
							gint _tmp77_;
							_tmp75_ = y;
							_tmp76_ = line;
							_tmp77_ = _tmp76_.y1;
							_tmp71_ = _tmp75_ == _tmp77_;
						} else {
							_tmp71_ = FALSE;
						}
						_tmp78_ = _tmp71_;
						if (_tmp78_) {
							_tmp70_ = TRUE;
						} else {
							gboolean _tmp79_ = FALSE;
							gint _tmp80_;
							PathLine _tmp81_;
							gint _tmp82_;
							gboolean _tmp86_;
							_tmp80_ = x;
							_tmp81_ = line;
							_tmp82_ = _tmp81_.x2;
							if (_tmp80_ == _tmp82_) {
								gint _tmp83_;
								PathLine _tmp84_;
								gint _tmp85_;
								_tmp83_ = y;
								_tmp84_ = line;
								_tmp85_ = _tmp84_.y2;
								_tmp79_ = _tmp83_ == _tmp85_;
							} else {
								_tmp79_ = FALSE;
							}
							_tmp86_ = _tmp79_;
							_tmp70_ = _tmp86_;
						}
						_tmp87_ = _tmp70_;
						if (_tmp87_) {
							result = 2;
							return result;
						}
						_tmp88_ = line;
						_tmp89_ = _tmp88_.x1;
						_tmp90_ = line;
						_tmp91_ = _tmp90_.x2;
						if (_tmp89_ < _tmp91_) {
							PathLine _tmp92_;
							gint _tmp93_;
							PathLine _tmp94_;
							gint _tmp95_;
							_tmp92_ = line;
							_tmp93_ = _tmp92_.x1;
							xMin = _tmp93_;
							_tmp94_ = line;
							_tmp95_ = _tmp94_.x2;
							xMax = _tmp95_;
						} else {
							PathLine _tmp96_;
							gint _tmp97_;
							PathLine _tmp98_;
							gint _tmp99_;
							_tmp96_ = line;
							_tmp97_ = _tmp96_.x2;
							xMin = _tmp97_;
							_tmp98_ = line;
							_tmp99_ = _tmp98_.x1;
							xMax = _tmp99_;
						}
						_tmp100_ = line;
						_tmp101_ = _tmp100_.y1;
						_tmp102_ = line;
						_tmp103_ = _tmp102_.y2;
						if (_tmp101_ < _tmp103_) {
							PathLine _tmp104_;
							gint _tmp105_;
							PathLine _tmp106_;
							gint _tmp107_;
							_tmp104_ = line;
							_tmp105_ = _tmp104_.y1;
							yMin = _tmp105_;
							_tmp106_ = line;
							_tmp107_ = _tmp106_.y2;
							yMax = _tmp107_;
						} else {
							PathLine _tmp108_;
							gint _tmp109_;
							PathLine _tmp110_;
							gint _tmp111_;
							_tmp108_ = line;
							_tmp109_ = _tmp108_.y2;
							yMin = _tmp109_;
							_tmp110_ = line;
							_tmp111_ = _tmp110_.y1;
							yMax = _tmp111_;
						}
						_tmp115_ = xMin;
						_tmp116_ = x;
						if (_tmp115_ <= _tmp116_) {
							gint _tmp117_;
							gint _tmp118_;
							_tmp117_ = x;
							_tmp118_ = xMax;
							_tmp114_ = _tmp117_ <= _tmp118_;
						} else {
							_tmp114_ = FALSE;
						}
						_tmp119_ = _tmp114_;
						if (_tmp119_) {
							gint _tmp120_;
							gint _tmp121_;
							_tmp120_ = yMin;
							_tmp121_ = y;
							_tmp113_ = _tmp120_ <= _tmp121_;
						} else {
							_tmp113_ = FALSE;
						}
						_tmp122_ = _tmp113_;
						if (_tmp122_) {
							gint _tmp123_;
							gint _tmp124_;
							_tmp123_ = y;
							_tmp124_ = yMax;
							_tmp112_ = _tmp123_ <= _tmp124_;
						} else {
							_tmp112_ = FALSE;
						}
						_tmp125_ = _tmp112_;
						if (_tmp125_) {
							gboolean _tmp126_ = FALSE;
							PathLine _tmp127_;
							gint _tmp128_;
							PathLine _tmp129_;
							gint _tmp130_;
							gboolean _tmp135_;
							PathLine _tmp136_;
							gint _tmp137_;
							PathLine _tmp138_;
							gint _tmp139_;
							gfloat xLineDiff;
							PathLine _tmp140_;
							gint _tmp141_;
							PathLine _tmp142_;
							gint _tmp143_;
							gfloat yLineDiff;
							gfloat _tmp144_;
							gfloat _tmp145_;
							gfloat gradient;
							gfloat _tmp146_ = 0.0F;
							gfloat _tmp147_;
							gfloat _tmp150_;
							gfloat gradientAbs;
							gfloat diff = 0.0F;
							gfloat diffAbs = 0.0F;
							gfloat _tmp151_;
							gfloat _tmp178_;
							_tmp127_ = line;
							_tmp128_ = _tmp127_.x1;
							_tmp129_ = line;
							_tmp130_ = _tmp129_.x2;
							if (_tmp128_ == _tmp130_) {
								_tmp126_ = TRUE;
							} else {
								PathLine _tmp131_;
								gint _tmp132_;
								PathLine _tmp133_;
								gint _tmp134_;
								_tmp131_ = line;
								_tmp132_ = _tmp131_.y1;
								_tmp133_ = line;
								_tmp134_ = _tmp133_.y2;
								_tmp126_ = _tmp132_ == _tmp134_;
							}
							_tmp135_ = _tmp126_;
							if (_tmp135_) {
								break;
							}
							_tmp136_ = line;
							_tmp137_ = _tmp136_.x2;
							_tmp138_ = line;
							_tmp139_ = _tmp138_.x1;
							xLineDiff = ((gfloat) _tmp137_) - ((gfloat) _tmp139_);
							_tmp140_ = line;
							_tmp141_ = _tmp140_.y2;
							_tmp142_ = line;
							_tmp143_ = _tmp142_.y1;
							yLineDiff = ((gfloat) _tmp141_) - ((gfloat) _tmp143_);
							_tmp144_ = yLineDiff;
							_tmp145_ = xLineDiff;
							gradient = _tmp144_ / _tmp145_;
							_tmp147_ = gradient;
							if (_tmp147_ < ((gfloat) 0)) {
								gfloat _tmp148_;
								_tmp148_ = gradient;
								_tmp146_ = -_tmp148_;
							} else {
								gfloat _tmp149_;
								_tmp149_ = gradient;
								_tmp146_ = _tmp149_;
							}
							_tmp150_ = _tmp146_;
							gradientAbs = _tmp150_;
							_tmp151_ = gradientAbs;
							if (_tmp151_ < ((gfloat) 1)) {
								gfloat _tmp152_;
								gint _tmp153_;
								PathLine _tmp154_;
								gint _tmp155_;
								PathLine _tmp156_;
								gint _tmp157_;
								gfloat yExpected;
								gint _tmp158_;
								gfloat _tmp159_;
								gfloat _tmp160_ = 0.0F;
								gfloat _tmp161_;
								gfloat _tmp164_;
								_tmp152_ = gradient;
								_tmp153_ = x;
								_tmp154_ = line;
								_tmp155_ = _tmp154_.x1;
								_tmp156_ = line;
								_tmp157_ = _tmp156_.y1;
								yExpected = (_tmp152_ * (((gfloat) _tmp153_) - ((gfloat) _tmp155_))) + ((gfloat) _tmp157_);
								_tmp158_ = y;
								_tmp159_ = yExpected;
								diff = _tmp158_ - _tmp159_;
								_tmp161_ = diff;
								if (_tmp161_ < ((gfloat) 0)) {
									gfloat _tmp162_;
									_tmp162_ = diff;
									_tmp160_ = -_tmp162_;
								} else {
									gfloat _tmp163_;
									_tmp163_ = diff;
									_tmp160_ = _tmp163_;
								}
								_tmp164_ = _tmp160_;
								diffAbs = _tmp164_;
							} else {
								gint _tmp165_;
								PathLine _tmp166_;
								gint _tmp167_;
								gfloat _tmp168_;
								PathLine _tmp169_;
								gint _tmp170_;
								gfloat xExpected;
								gint _tmp171_;
								gfloat _tmp172_;
								gfloat _tmp173_ = 0.0F;
								gfloat _tmp174_;
								gfloat _tmp177_;
								_tmp165_ = y;
								_tmp166_ = line;
								_tmp167_ = _tmp166_.y1;
								_tmp168_ = gradient;
								_tmp169_ = line;
								_tmp170_ = _tmp169_.x1;
								xExpected = ((((gfloat) _tmp165_) - ((gfloat) _tmp167_)) / _tmp168_) + ((gfloat) _tmp170_);
								_tmp171_ = x;
								_tmp172_ = xExpected;
								diff = _tmp171_ - _tmp172_;
								_tmp174_ = diff;
								if (_tmp174_ < ((gfloat) 0)) {
									gfloat _tmp175_;
									_tmp175_ = diff;
									_tmp173_ = -_tmp175_;
								} else {
									gfloat _tmp176_;
									_tmp176_ = diff;
									_tmp173_ = _tmp176_;
								}
								_tmp177_ = _tmp173_;
								diffAbs = _tmp177_;
							}
							_tmp178_ = diffAbs;
							if (_tmp178_ <= ((gfloat) 5)) {
								result = 1;
								return result;
							}
						}
						break;
					}
					default:
					break;
				}
			}
		}
	}
	result = 0;
	return result;
}


/**
 * Displaces the path by //x// horizontally, and //y// vertically.
 */
void path_move (Path* self, gint x, gint y) {
	gint _tmp29_;
	gint _tmp30_;
	gint _tmp31_;
	gint _tmp32_;
	gint _tmp33_;
	gint _tmp34_;
	gint _tmp35_;
	gint _tmp36_;
	g_return_if_fail (self != NULL);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gboolean _tmp1_;
				gint _tmp3_;
				PathLine* _tmp4_;
				gint _tmp4__length1;
				PathLine* _tmp5_;
				gint _tmp5__length1;
				gint _tmp6_;
				PathLine* _tmp7_;
				gint _tmp7__length1;
				gint _tmp8_;
				gint _tmp9_;
				gint _tmp10_;
				PathLine* _tmp11_;
				gint _tmp11__length1;
				gint _tmp12_;
				PathLine* _tmp13_;
				gint _tmp13__length1;
				gint _tmp14_;
				gint _tmp15_;
				gint _tmp16_;
				PathLine* _tmp17_;
				gint _tmp17__length1;
				gint _tmp18_;
				PathLine* _tmp19_;
				gint _tmp19__length1;
				gint _tmp20_;
				gint _tmp21_;
				gint _tmp22_;
				PathLine* _tmp23_;
				gint _tmp23__length1;
				gint _tmp24_;
				PathLine* _tmp25_;
				gint _tmp25__length1;
				gint _tmp26_;
				gint _tmp27_;
				gint _tmp28_;
				_tmp1_ = _tmp0_;
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp0_ = FALSE;
				_tmp3_ = i;
				_tmp4_ = self->lines;
				_tmp4__length1 = self->lines_length1;
				if (!(_tmp3_ < _tmp4__length1)) {
					break;
				}
				_tmp5_ = self->lines;
				_tmp5__length1 = self->lines_length1;
				_tmp6_ = i;
				_tmp7_ = self->lines;
				_tmp7__length1 = self->lines_length1;
				_tmp8_ = i;
				_tmp9_ = _tmp7_[_tmp8_].x1;
				_tmp10_ = x;
				_tmp7_[_tmp8_].x1 = _tmp9_ + _tmp10_;
				_tmp11_ = self->lines;
				_tmp11__length1 = self->lines_length1;
				_tmp12_ = i;
				_tmp13_ = self->lines;
				_tmp13__length1 = self->lines_length1;
				_tmp14_ = i;
				_tmp15_ = _tmp13_[_tmp14_].y1;
				_tmp16_ = y;
				_tmp13_[_tmp14_].y1 = _tmp15_ + _tmp16_;
				_tmp17_ = self->lines;
				_tmp17__length1 = self->lines_length1;
				_tmp18_ = i;
				_tmp19_ = self->lines;
				_tmp19__length1 = self->lines_length1;
				_tmp20_ = i;
				_tmp21_ = _tmp19_[_tmp20_].x2;
				_tmp22_ = x;
				_tmp19_[_tmp20_].x2 = _tmp21_ + _tmp22_;
				_tmp23_ = self->lines;
				_tmp23__length1 = self->lines_length1;
				_tmp24_ = i;
				_tmp25_ = self->lines;
				_tmp25__length1 = self->lines_length1;
				_tmp26_ = i;
				_tmp27_ = _tmp25_[_tmp26_].y2;
				_tmp28_ = y;
				_tmp25_[_tmp26_].y2 = _tmp27_ + _tmp28_;
			}
		}
	}
	_tmp29_ = self->xLast;
	_tmp30_ = x;
	self->xLast = _tmp29_ + _tmp30_;
	_tmp31_ = self->yLast;
	_tmp32_ = y;
	self->yLast = _tmp31_ + _tmp32_;
	_tmp33_ = self->xLineStart;
	_tmp34_ = x;
	self->xLineStart = _tmp33_ + _tmp34_;
	_tmp35_ = self->yLineStart;
	_tmp36_ = y;
	self->yLineStart = _tmp35_ + _tmp36_;
}


/**
 * Renders the path's lines.
 */
void path_render (Path* self, cairo_t* context) {
	PathLine* _tmp0_;
	gint _tmp0__length1;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	_tmp0_ = self->lines;
	_tmp0__length1 = self->lines_length1;
	{
		PathLine* line_collection = NULL;
		gint line_collection_length1 = 0;
		gint _line_collection_size_ = 0;
		gint line_it = 0;
		line_collection = _tmp0_;
		line_collection_length1 = _tmp0__length1;
		for (line_it = 0; line_it < _tmp0__length1; line_it = line_it + 1) {
			PathLine line = {0};
			line = line_collection[line_it];
			{
				cairo_t* _tmp1_;
				PathLine _tmp2_;
				gint _tmp3_;
				PathLine _tmp4_;
				gint _tmp5_;
				cairo_t* _tmp6_;
				PathLine _tmp7_;
				gint _tmp8_;
				PathLine _tmp9_;
				gint _tmp10_;
				cairo_t* _tmp11_;
				_tmp1_ = context;
				_tmp2_ = line;
				_tmp3_ = _tmp2_.x1;
				_tmp4_ = line;
				_tmp5_ = _tmp4_.y1;
				cairo_move_to (_tmp1_, (gdouble) _tmp3_, (gdouble) _tmp5_);
				_tmp6_ = context;
				_tmp7_ = line;
				_tmp8_ = _tmp7_.x2;
				_tmp9_ = line;
				_tmp10_ = _tmp9_.y2;
				cairo_line_to (_tmp6_, (gdouble) _tmp8_, (gdouble) _tmp10_);
				_tmp11_ = context;
				cairo_stroke (_tmp11_);
			}
		}
	}
}


PathLine* path_line_dup (const PathLine* self) {
	PathLine* dup;
	dup = g_new0 (PathLine, 1);
	memcpy (dup, self, sizeof (PathLine));
	return dup;
}


void path_line_free (PathLine* self) {
	g_free (self);
}


GType path_line_get_type (void) {
	static volatile gsize path_line_type_id__volatile = 0;
	if (g_once_init_enter (&path_line_type_id__volatile)) {
		GType path_line_type_id;
		path_line_type_id = g_boxed_type_register_static ("PathLine", (GBoxedCopyFunc) path_line_dup, (GBoxedFreeFunc) path_line_free);
		g_once_init_leave (&path_line_type_id__volatile, path_line_type_id);
	}
	return path_line_type_id__volatile;
}


static void value_path_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_path_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		path_unref (value->data[0].v_pointer);
	}
}


static void value_path_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = path_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_path_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_path_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Path* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = path_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_path_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Path** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = path_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_path (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecPath* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_PATH), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_path (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PATH), NULL);
	return value->data[0].v_pointer;
}


void value_set_path (GValue* value, gpointer v_object) {
	Path* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PATH));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_PATH));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		path_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		path_unref (old);
	}
}


void value_take_path (GValue* value, gpointer v_object) {
	Path* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PATH));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_PATH));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		path_unref (old);
	}
}


static void path_class_init (PathClass * klass) {
	path_parent_class = g_type_class_peek_parent (klass);
	PATH_CLASS (klass)->finalize = path_finalize;
}


static void path_instance_init (Path * self) {
	self->ref_count = 1;
}


static void path_finalize (Path* obj) {
	Path * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PATH, Path);
	self->lines = (g_free (self->lines), NULL);
}


/**
 * Describes a path of straight lines.
 * 
 * Used (sometimes in groups) to describe the structure of a wire.
 */
GType path_get_type (void) {
	static volatile gsize path_type_id__volatile = 0;
	if (g_once_init_enter (&path_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_path_init, value_path_free_value, value_path_copy_value, value_path_peek_pointer, "p", value_path_collect_value, "p", value_path_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (PathClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) path_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Path), 0, (GInstanceInitFunc) path_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType path_type_id;
		path_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Path", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&path_type_id__volatile, path_type_id);
	}
	return path_type_id__volatile;
}


gpointer path_ref (gpointer instance) {
	Path* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void path_unref (gpointer instance) {
	Path* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		PATH_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



